{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    function changeAdmin(address) external;\n\n    function upgradeTo(address) external;\n\n    function upgradeToAndCall(address, bytes memory) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     *\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\n     * implementation provides a function with the same selector.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n                ret = _dispatchUpgradeTo();\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                ret = _dispatchUpgradeToAndCall();\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n                ret = _dispatchChangeAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n                ret = _dispatchAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n                ret = _dispatchImplementation();\n            } else {\n                revert(\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n            }\n            assembly {\n                return(add(ret, 0x20), mload(ret))\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function _dispatchAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address admin = _getAdmin();\n        return abi.encode(admin);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _dispatchImplementation() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address implementation = _implementation();\n        return abi.encode(implementation);\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _dispatchChangeAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newAdmin = abi.decode(msg.data[4:], (address));\n        _changeAdmin(newAdmin);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     */\n    function _dispatchUpgradeTo() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newImplementation = abi.decode(msg.data[4:], (address));\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     */\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        _upgradeToAndCall(newImplementation, data, true);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * CAUTION: This function is deprecated. Use {ERC1967Upgrade-_getAdmin} instead.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\n     */\n    function _requireZeroValue() private {\n        require(msg.value == 0);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/v1/common/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\nimport \"../interface/IAuth.sol\";\n/// @title  Auth\n/// @notice Simple authentication pattern\n/// @author Based on code from https://github.com/makerdao/dss\nabstract contract Auth is IAuth {\n    /// @inheritdoc IAuth\n    mapping(address => uint256) public override wards;\n\n    constructor(address initialWard) {\n        wards[initialWard] = 1;\n        emit Rely(initialWard);\n    }\n\n    /// @dev Check if the msg.sender has permissions\n    modifier auth() {\n        require(wards[msg.sender] == 1, \"Auth/not-authorized\");\n        _;\n    }\n\n    /// @inheritdoc IAuth\n    function rely(address user) external override auth {\n        wards[user] = 1;\n        emit Rely(user);\n    }\n\n    /// @inheritdoc IAuth\n    function deny(address user) external override auth {\n        wards[user] = 0;\n        emit Deny(user);\n    }\n}"
    },
    "contracts/v1/common/Escrow.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./Auth.sol\";\nimport \"../interface/IEscrow.sol\";\n\n\n/// @title  Escrow\n/// @notice Escrow contract that holds tokens.\n///         Only wards can approve funds to be taken out.\n/// @author Based on code from https://github.com/centrifuge/liquidity-pools\ncontract Escrow is Auth, IEscrow {\n    \n    constructor(address deployer) Auth(deployer) {}\n\n    // --- Token approvals ---\n    /// @inheritdoc IEscrow\n    function approveMax(address token, address spender) external override auth {\n        if (IERC20(token).allowance(address(this), spender) == 0) {\n            SafeERC20.safeApprove(IERC20(token), spender, type(uint256).max);\n            emit Approve(token, spender, type(uint256).max);\n        }\n    }\n    \n    /// @inheritdoc IEscrow\n    function unapprove(address token, address spender) external override auth {\n        SafeERC20.safeApprove(IERC20(token), spender, 0);\n        emit Approve(token, spender, 0);\n    }\n\n}"
    },
    "contracts/v1/factories/EscrowFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\nimport \"../interface/IEscrowFactory.sol\";\nimport \"../common/Auth.sol\";\nimport \"../common/Escrow.sol\";\n/**\n * @author  Accelerate Finance\n * @title   EscrowFactory\n * @dev     This contract is responsible for creating new instances of the Escrow contract.\n * @notice  Allows authorized users to deploy new Escrow contracts.\n */\ncontract EscrowFactory is Auth, IEscrowFactory {\n\n    /**\n     * @notice Constructor function that initializes the contract and sets the deployer as the authorized user.\n     * @dev Inherits from the Auth contract to implement access control.\n     * @param deployer The address of the entity deploying the contract, serving as the initial administrator.\n     */\n    constructor(address deployer) Auth(deployer) {}\n    \n    /**\n     * @notice  Creates a new instance of the Escrow contract.\n     * @dev     Only authorized users can call this function.\n     * @param   deployer The address of the deployer for the new Escrow contract.\n     * @return  address  The address of the newly created Escrow contract.\n     */\n    function newEscrow(address deployer) public auth override returns (address) {\n        Escrow escrow = new Escrow(deployer);\n        emit EscrowDeployed(address(escrow));\n        return address(escrow);\n    }\n\n}"
    },
    "contracts/v1/factories/PriceFeedFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\nimport \"../interface/IPriceFeedFactory.sol\";\nimport \"../common/Auth.sol\";\nimport \"../rbf/PriceFeed.sol\";\n\n/**\n * @author  Accelerate Finance\n * @title   PriceFeedFactory\n * @dev     This contract is responsible for creating new instances of the PriceFeedFactory contract.\n * @notice  Allows authorized users to deploy new PriceFeedFactory contracts.\n */\ncontract PriceFeedFactory is Auth, IPriceFeedFactory {\n    /**\n     * @notice Constructor function that initializes the contract and sets the deployer as the authorized user.\n     * @dev Inherits from the Auth contract to implement access control.\n     * @param deployer The address of the entity deploying the contract, serving as the initial administrator.\n     */\n    constructor(address deployer) Auth(deployer) {}\n\n    /**\n     * @notice  Creates a new instance of the PriceFeed contract.\n     * @dev     Only authorized users can call this function.\n     * @param   manager  The address of the manager for the new PriceFeed contract.\n     * @return  address  The address of the newly created PriceFeed contract.\n     */\n    function newPriceFeed(\n        address manager\n    ) public auth override returns (address){\n        PriceFeed pricer = new PriceFeed(manager);\n        emit PriceFeedDeployed(address(pricer));\n        return address(pricer);\n    }\n\n}"
    },
    "contracts/v1/factories/RBFFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"../interface/IRBFFactory.sol\";\nimport \"../common/Auth.sol\";\nimport \"../rbf/RBF.sol\";\n\n\n/**\n * @author  Accelerate Finance\n * @title   RBFFactory\n * @dev     This contract is responsible for deploying and managing instances of the RBF contract.\n *\n * @notice  This contract serves as a Factory for the upgradable RBF token contract.\n *          Upon calling `newRBF` the caller address will\n *          deploy the following:\n *          1) RBF - The implementation contract, ERC20Upgradeable contract with the constructor disabled\n *          2) ProxyAdmin - OZ ProxyAdmin contract, used to upgrade the proxy instance.\n *                          Owner is set to `guardian` address.\n *          3) TransparentUpgradeableProxy - OZ TransparentUpgradeableProxy contract, used to proxy the implementation.\n *          Following the above mentioned deployment, the address of the RBFFactory contract will:\n *          i) Transfer ownership of the ProxyAdmin to that of the `guardian` address.\n *          ii) Transfer ownership of the rbfProxied to that of the msg.sender address.\n *\n */\ncontract RBFFactory is Auth, IRBFFactory {\n    event RBFDeployed(\n        address proxy,\n        address proxyAdmin,\n        address implementation,\n        address guardian\n    );\n\n    /**\n     * @notice Constructor function that initializes the contract and sets the deployer as the authorized user.\n     * @dev Inherits from the Auth contract to implement access control.\n     * @param deployer The address of the entity deploying the contract, serving as the initial administrator.\n     */\n    constructor(address deployer) Auth(deployer) {}\n\n    /**\n     * @notice  Creates a new instance of the RBF contract using an upgradeable proxy.\n     * @dev     Deploys a new implementation of RBF, a ProxyAdmin, and a TransparentUpgradeableProxy.\n     *          Transfers ownership of the proxy admin to the guardian and the RBF to the caller.\n     * @param   data  The initialization data for the RBF contract.\n     * @param   guardian  The address that will take ownership of the proxy admin.\n     * @return  address   The address of the newly created RBF proxy contract.\n     * @return  address   The address of the newly created proxy admin contract.\n     * @return  address   The address of the newly created RBF implementation contract.\n     */\n    function newRBF(\n        RBFInitializeData memory data,\n        address guardian\n    ) public override auth returns (address, address, address) {\n        RBF rbfImplementation = new RBF();\n        ProxyAdmin rbfProxyAdmin = new ProxyAdmin();\n        TransparentUpgradeableProxy rbfProxy = new TransparentUpgradeableProxy(\n            address(rbfImplementation),\n            address(rbfProxyAdmin),\n            \"\"\n        );\n        RBF rbfProxied = RBF(address(rbfProxy));\n        rbfProxied.initialize(data);\n        rbfProxyAdmin.transferOwnership(guardian);\n        rbfProxied.transferOwnership(msg.sender);\n        assert(rbfProxyAdmin.owner() == guardian);\n        assert(rbfProxied.owner() == msg.sender);\n        emit RBFDeployed(\n            address(rbfProxied),\n            address(rbfProxyAdmin),\n            address(rbfImplementation),\n            guardian\n        );\n\n        return (\n            address(rbfProxied),\n            address(rbfProxyAdmin),\n            address(rbfImplementation)\n        );\n    }\n}"
    },
    "contracts/v1/factories/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"../interface/IVaultFactory.sol\";\nimport \"../common/Auth.sol\";\nimport \"../vault/Vault.sol\";\n\n\n/**\n * @author  Accelerate Finance\n * @title   VaultFactory\n * @dev     This contract is responsible for deploying and managing instances of the Vault contract.\n * @notice  This contract serves as a Factory for the upgradable Vault token contract.\n *          Upon calling `newVault` the caller address will\n *          deploy the following:\n *          1) Vault - The implementation contract, ERC20Upgradeable contract with the constructor disabled\n *          2) ProxyAdmin - OZ ProxyAdmin contract, used to upgrade the proxy instance.\n *                          Owner is set to `guardian` address.\n *          3) TransparentUpgradeableProxy - OZ TransparentUpgradeableProxy contract, used to proxy the implementation.\n *          Following the above mentioned deployment, the address of the VaultFactory contract will:\n *          i) Transfer ownership of the ProxyAdmin to that of the `guardian` address.\n *          ii) Transfer ownership of the vaultProxied to that of the `msg.sender` address.\n */\ncontract VaultFactory is Auth, IVaultFactory {\n    event VaultDeployed(\n        address proxy,\n        address proxyAdmin,\n        address implementation,\n        address guardian\n    );\n\n    /**\n     * @notice Constructor function that initializes the contract and sets the deployer as the authorized user.\n     * @dev Inherits from the Auth contract to implement access control.\n     * @param deployer The address of the entity deploying the contract, serving as the initial administrator.\n     */\n    constructor(address deployer) Auth(deployer) {}\n\n    /**\n     * @notice  Creates a new instance of the Vault contract using an upgradeable proxy.\n     * @dev     Deploys a new implementation of Vault, a ProxyAdmin, and a TransparentUpgradeableProxy.\n     *          Transfers ownership of the proxy admin to the guardian and the Vault to the caller.\n     * @param   data  The initialization data for the Vault contract.\n     * @param   guardian  The address that will take ownership of the proxy admin.\n     * @return  address   The address of the newly created Vault proxy contract.\n     * @return  address   The address of the newly created proxy admin contract.\n     * @return  address   The address of the newly created Vault implementation contract.\n     */\n    function newVault(\n        VaultInitializeData memory data,\n        address guardian\n    ) public override auth returns (address, address, address) {\n        Vault vaultImplementation = new Vault();\n        ProxyAdmin vaultProxyAdmin = new ProxyAdmin();\n        TransparentUpgradeableProxy vaultProxy = new TransparentUpgradeableProxy(\n                address(vaultImplementation),\n                address(vaultProxyAdmin),\n                \"\"\n            );\n        Vault vaultProxied = Vault(address(vaultProxy));\n        vaultProxied.initialize(data);\n        vaultProxyAdmin.transferOwnership(guardian);\n        vaultProxied.transferOwnership(msg.sender);\n        emit VaultDeployed(\n            address(vaultProxy),\n            address(vaultProxyAdmin),\n            address(vaultImplementation),\n            guardian\n        );\n\n        return (\n            address(vaultProxy),\n            address(vaultProxyAdmin),\n            address(vaultImplementation)\n        );\n    }\n}"
    },
    "contracts/v1/interface/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n\n    event PriceUpdated(uint80 roundId, int256 price, uint256 timestamp);\n}\n"
    },
    "contracts/v1/interface/IAuth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.26;\n\ninterface IAuth {\n    /// @notice Returns whether the target is a ward (has admin access)\n    function wards(address target) external view returns (uint256);\n\n    /// @notice Make user a ward (give them admin access)\n    function rely(address user) external;\n\n    /// @notice Remove user as a ward (remove admin access)\n    function deny(address user) external;\n\n    event Rely(address indexed user);\n    event Deny(address indexed user);\n}\n"
    },
    "contracts/v1/interface/IEscrow.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\ninterface IEscrow {\n    // --- Events ---\n    event Approve(address indexed token, address indexed spender, uint256 value);\n\n    // --- Token approvals ---\n    /// @notice sets the allowance of `spender` to `type(uint256).max` if it is currently 0\n    function approveMax(address token, address spender) external;\n\n    /// @notice sets the allowance of `spender` to 0\n    function unapprove(address token, address spender) external;\n}\n"
    },
    "contracts/v1/interface/IEscrowFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\ninterface IEscrowFactory {\n    \n    /**\n     * @notice  Creates a new instance of the Escrow contract.\n     * @dev     Only authorized users can call this function.\n     * @param   deployer The address of the deployer for the new Escrow contract.\n     * @return  address  The address of the newly created Escrow contract.\n     */\n    function newEscrow(address deployer) external returns (address);\n\n    /**\n     * @notice Event emitted when Escrow is deployed.\n     *\n     * @param escrow deployed Escrow address.\n     */\n    event EscrowDeployed(address indexed escrow);\n}\n"
    },
    "contracts/v1/interface/IPriceFeedFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\ninterface IPriceFeedFactory {\n    /**\n     * @notice  Creates a new instance of the PriceFeed contract.\n     * @dev     Only authorized users can call this function.\n     * @param   manager  The address of the manager for the new PriceFeed contract.\n     * @return  address  The address of the newly created PriceFeed contract.\n     */\n    function newPriceFeed(address manager) external returns (address);\n\n    /**\n     * @notice Event emitted when PriceFeed is deployed.\n     *\n     * @param priceFeed deployed PriceFeed address.\n     */\n    event PriceFeedDeployed(address indexed priceFeed);\n}\n"
    },
    "contracts/v1/interface/IRBF.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\ninterface IRBF {\n    event DepositEvent(address depositor, uint256 amount);\n    event ClaimDepositEvent(address receiver,uint256 depositAmount,uint256 mintAmount);\n    event DepositDataEvent(uint256 depositMintAmount);\n    event SetVault(address vault);\n    event SetTokenURI(string tokenURI);\n}\n"
    },
    "contracts/v1/interface/IRBFFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\nimport \"../rbf/RBF.sol\";\n\ninterface IRBFFactory {\n     /**\n     * @notice  Creates a new instance of the RBF contract using an upgradeable proxy.\n     * @dev     Deploys a new implementation of RBF, a ProxyAdmin, and a TransparentUpgradeableProxy.\n     *          Transfers ownership of the proxy admin to the guardian and the RBF to the caller.\n     * @param   data  The initialization data for the RBF contract.\n     * @param   guardian  The address that will take ownership of the proxy admin.\n     * @return  address   The address of the newly created RBF proxy contract.\n     * @return  address   The address of the newly created proxy admin contract.\n     * @return  address   The address of the newly created RBF implementation contract.\n     */\n    function newRBF(\n        RBFInitializeData memory data,\n        address guardian\n    ) external returns (address, address, address);\n\n}\n"
    },
    "contracts/v1/interface/IRBFRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\n\ninterface IRBFRouter {\n\n     /**\n     * @notice  Deploys a new RBF contract after verifying signatures.\n     * @dev     Decodes the deployment data, verifies signatures, and deploys the RBF contract along with escrow and price feed.\n     * @param   deployData  Encoded data containing deployment parameters.\n     * @param   signatures  Array of signatures for verification.\n     */\n    function deployRBF(\n        bytes memory deployData,\n        bytes[] memory signatures\n    ) external;\n\n    event DeployRBFEvent(\n        uint64 rbfId,\n        address priceFeed,\n        address rbf,\n        address dividendTreasury\n    );\n\n    event SetWhiteListsAndThreshold(\n        address[] whiteLists,\n        uint256 threshold\n    );\n}"
    },
    "contracts/v1/interface/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\ninterface IVault {\n\n    event SetManager(address manager);\n    event FundFailRedeem(address redeemer,uint256 shares,uint256 assetAmount,uint256 feeAmount);\n    event OffChainDepositEvent(address operator,address receiver,uint256 amount);\n    event OffChainRedeemEvent(address redeemer,uint256 shares);\n    event DepositEvent(address depositor,uint256 assetAmount,uint256 manageFeeAmount,uint256 shares);\n    event ExecStrategyEvent(uint256 depositAmount);\n\n    function deposit(\n        uint256 assets\n    ) external  returns (uint256);\n\n    function redeem() external returns (uint256);\n\n}"
    },
    "contracts/v1/interface/IVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\nimport \"../vault/Vault.sol\";\ninterface IVaultFactory {\n    function newVault(\n        VaultInitializeData memory data,\n        address guardian\n    ) external returns (address,address,address); \n}"
    },
    "contracts/v1/interface/IVaultRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\nstruct VaultDeployData {\n    uint64 vaultId;\n    string name;\n    string symbol;\n    address assetToken;\n    address rbf;\n    uint256 maxSupply;\n    uint256 subStartTime;\n    uint256 subEndTime;\n    uint256 duration;\n    uint256 fundThreshold;\n    uint256 financePrice;\n    uint256 minDepositAmount;\n    uint256 manageFee;\n    address manager;\n    address feeReceiver;\n    address[] whitelists;\n    address guardian;\n}\ninterface IVaultRouter {\n    event DeployVaultEvent(\n        uint64 vaultId,\n        address vault,\n        address dividendEscrow\n    );\n\n    function deployVault(VaultDeployData memory vaultDeployData) external;\n    \n}"
    },
    "contracts/v1/MockUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockUSDT is ERC20 {\n    event Mint(address indexed account, uint256 amount);\n    event Burn(address indexed account, uint256 amount);\n\n    constructor(\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) {}\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n        emit Mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external {\n        _spendAllowance(from, msg.sender, amount);\n        _burn(from, amount);\n        emit Burn(from, amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n}\n"
    },
    "contracts/v1/rbf/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\n\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"../interface/AggregatorV3Interface.sol\";\n\n/**\n * @author  Accelerate Finance\n * @title   PriceFeed\n * @dev     Implements a simple price feed mechanism with role-based access control.\n * @notice  The contract follows the AggregatorV3Interface and allows authorized users to update price data.\n */\ncontract PriceFeed is AggregatorV3Interface, AccessControl {\n    struct RoundData {\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n    }\n\n    bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n    bytes32 public constant FEEDER_ROLE = keccak256(\"FEEDER_ROLE\");\n    // Mapping to store round data, where the key is the round ID and the value is a RoundData struct\n    mapping(uint80 => RoundData) private rounds;\n    // Stores the latest round ID, which increments each time new data is added\n    uint80 private latestRoundId;\n\n    constructor(address manager) {\n        _grantRole(DEFAULT_ADMIN_ROLE, manager);\n        _grantRole(MANAGER_ROLE, manager);\n        _setRoleAdmin(FEEDER_ROLE, MANAGER_ROLE);\n    }\n\n    /**\n     * @notice  Allows a user with the FEEDER_ROLE to add a new price entry.\n     * @dev     Only addresses with FEEDER_ROLE can call this function\n     * @param   price  The new price value to store.\n     * @param   priceTime  Timestamp of the price update.\n     */\n    function addPrice(\n        int256 price,\n        uint256 priceTime\n    ) public onlyRole(FEEDER_ROLE) {\n        _addPrice(price, priceTime);\n    }\n\n    /**\n     * @notice  Returns the description of the price feed.\n     * @return  string  A string representing the price feed pair.\n     */\n    function description() public pure override returns (string memory) {\n        return \"RBFToken/USD\";\n    }\n\n    /**\n     * @notice  Returns the version of the contract.\n     * @return  uint256  The version number as a uint256.\n     */\n    function version() public pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice  Returns the number of decimal places used for the price values.\n     * @return  uint8  The number of decimals.\n     */\n    function decimals() public pure override returns (uint8) {\n        return 8;\n    }\n\n    /**\n     * @notice  Retrieves price data for a specific round.\n     * @param   roundId The round ID to query.\n     * @return  uint80  roundId The queried round ID.\n     * @return  int256  answer The price recorded for this round.\n     * @return  uint256  startedAt Timestamp when the round started.\n     * @return  uint256  updatedAt Timestamp when the price was last updated.\n     * @return  uint80  answeredInRound The round ID for which the price was answered.\n     */\n    function getRoundData(\n        uint80 roundId\n    ) public view override returns (uint80, int256, uint256, uint256, uint80) {\n        require(rounds[roundId].updatedAt > 0, \"No data for this round\");\n        RoundData memory round = rounds[roundId];\n        return (\n            roundId,\n            round.answer,\n            round.startedAt,\n            round.updatedAt,\n            round.answeredInRound\n        );\n    }\n\n    /**\n     * @notice  Retrieves the latest round data.\n     * @return  uint80  latestRoundId The most recent round ID.\n     * @return  int256  answer The price recorded in the latest round.\n     * @return  uint256  startedAt Timestamp when the latest round started.\n     * @return  uint256  updatedAt Timestamp when the latest price update occurred.\n     * @return  uint80   answeredInRound The round ID for which the latest price was answered.\n     */\n    function latestRoundData()\n        external\n        view\n        override\n        returns (uint80, int256, uint256, uint256, uint80)\n    {\n        require(latestRoundId > 0, \"No price data available\");\n        RoundData memory round = rounds[latestRoundId];\n        return (\n            latestRoundId,\n            round.answer,\n            round.startedAt,\n            round.updatedAt,\n            round.answeredInRound\n        );\n    }\n\n    function _addPrice(int256 price, uint256 priceTime) internal {\n        latestRoundId++;\n        rounds[latestRoundId] = RoundData({\n            answer: price,\n            startedAt: priceTime,\n            updatedAt: priceTime,\n            answeredInRound: latestRoundId\n        });\n\n        emit PriceUpdated(latestRoundId, price, priceTime);\n    }\n}"
    },
    "contracts/v1/rbf/RBF.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../vault/Vault.sol\";\nimport \"../interface/AggregatorV3Interface.sol\";\nimport \"../interface/IRBF.sol\";\n\nstruct RBFInitializeData {\n    string name; // The name of the RBF contract\n    string symbol; // The symbol of the RBF contract (usually a ticker like \"RBF\")\n    address assetToken; // The address of the ERC20 token used in the RBF contract (e.g., USDC, ETH)\n    address depositTreasury; // The address that receives the deposits from the vault\n    address dividendTreasury; // The address where dividends (profits) will be stored and distributed\n    address priceFeed; // The address of the price feed (e.g., Chainlink) to get the asset price for RBF calculations\n    address manager; // The address of the contract manager who can dividend in the RBF contract\n}\n\n/**\n * @author  Accelerate Finance\n * @title   RBF\n * @dev     A contract for handling deposit and minting of RBF tokens, managing dividends, and controlling access by the manager.\n * @notice  This contract allows deposits in an underlying asset token and mints a corresponding amount of RBF tokens based on the deposit and the asset's price. It also supports dividend distribution and fee management by manager.\n */\ncontract RBF is\n    IRBF,\n    OwnableUpgradeable,\n    ERC20Upgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n    uint256 public constant BPS_DENOMINATOR = 10_000;\n    bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n    bytes32 public constant MINT_AMOUNT_SETTER_ROLE =\n        keccak256(\"MINT_AMOUNT_SETTER_ROLE\");\n    // The address of the asset token that this contract interacts with (e.g., an ERC-20 token).\n    address public assetToken;\n    // The address of the treasury that holds deposited assets.\n    address public depositTreasury; \n    // The address of the treasury responsible for distributing dividends to rbfholders.\n    address public dividendTreasury;\n    // The price feed contract used to fetch price data for the asset.  \n    AggregatorV3Interface public priceFeed;\n    // The address of the manager who has administrative privileges over the contract.\n    address public manager;\n    // The address of the vault  which can deposit assetToken.\n    address public vault;\n    // The amount of assetToken deposited into the depositTreasury.\n    uint256 public depositAmount;\n    // The amount of RBF tokens minted for assetToken deposited.\n    uint256 public depositMintAmount;\n    // The URI of the rbf token. \n    string public tokenURI;\n\n    modifier onlyVault() {\n        require(msg.sender == vault, \"RBF: you are not vault\");\n        _;\n    }\n\n    /**\n     * @dev  Constructor function to disable initializers\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice  Initializes the RBF contract with required parameters.\n     * @param   data  Initialization data containing contract configuration.\n     */\n    function initialize(RBFInitializeData memory data) public initializer {\n        __ReentrancyGuard_init();\n        __ERC20_init(data.name, data.symbol);\n        __Ownable_init();\n\n        require(\n            data.assetToken != address(0),\n            \"RBF: assetToken address cannot be zero address\"\n        );\n        assetToken = data.assetToken;\n        require(\n            data.depositTreasury != address(0),\n            \"RBF: depositTreasury address cannot be zero address\"\n        );\n        depositTreasury = data.depositTreasury;\n        require(\n            data.dividendTreasury != address(0),\n            \"RBF: dividendTreasury address cannot be zero address\"\n        );\n        dividendTreasury = data.dividendTreasury;\n        require(\n            data.priceFeed != address(0),\n            \"RBF: priceFeedAddr can not be zero address\"\n        );\n        priceFeed = AggregatorV3Interface(data.priceFeed);\n        require(\n            data.manager != address(0),\n            \"RBF: manager address can not be zero address\"\n        );\n        manager = data.manager;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, data.manager);\n        _grantRole(MANAGER_ROLE, data.manager);\n        _setRoleAdmin(MINT_AMOUNT_SETTER_ROLE, MANAGER_ROLE);\n        \n    }\n\n    /*//////////////////////////////////////////////////////////////\n                  Deposit/Dividend Functions\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice  Deposits assetToken into the RBF contract.\n     * @dev     This function is only callable by the Vault.\n     * @param   amount The amount of assetToken to deposit.\n     */\n    function requestDeposit(uint256 amount) public onlyVault nonReentrant {\n        require(\n            IERC20(assetToken).balanceOf(msg.sender) >= amount,\n            \"RBF: Insufficient balance\"\n        );\n        depositAmount += amount;\n        SafeERC20.safeTransferFrom(\n            IERC20(assetToken),\n            msg.sender,\n            depositTreasury,\n            amount\n        );\n        emit DepositEvent(msg.sender,amount);\n    }\n\n    /**\n     * @notice  Allows the manager to claim the deposit and mint RBF tokens.\n     * @dev     This function is only callable by the manager role.\n     */\n    function claimDeposit() public onlyRole(MANAGER_ROLE) {\n        require(depositAmount > 0, \"RBF: depositAmount must be greater than 0\");\n        require(\n            depositMintAmount > 0,\n            \"RBF: depositMintAmount must be greater than 0\"\n        );\n        _mint(vault, depositMintAmount);\n        emit ClaimDepositEvent(vault,depositAmount,depositMintAmount);\n        depositAmount = 0;\n        depositMintAmount=0;\n    }\n\n    /**\n     * @notice  Allows the manager to distribute dividends from the dividend treasury to the vault.\n     * @dev     This function calculates the dividend share for the vault and transfers the dividend amount.\n     */\n    function dividend() public onlyRole(MANAGER_ROLE) nonReentrant {\n        uint256 totalDividend = IERC20(assetToken).balanceOf(dividendTreasury);\n        require(totalDividend > 0, \"RBF: totalDividend must be greater than 0\");\n        uint256 totalSupply = totalSupply();\n        require(totalSupply > 0, \"RBF: totalSupply must be greater than 0\");\n        require(vault != address(0), \"RBF: vault can not be zero address\");\n        require(\n            balanceOf(vault) > 0,\n            \"RBF: vault balance must be greater than 0\"\n        );\n        address vaultDividendTreasury = Vault(vault).dividendTreasury();\n        require(\n            vaultDividendTreasury != address(0),\n            \"RBF: vault dividendTreasury cant not be zero\"\n        );\n        _dividend(\n            balanceOf(vault),\n            totalSupply,\n            totalDividend,\n            vaultDividendTreasury\n        );\n    }\n\n    /**\n     * @notice  Sets the deposit price and mint amount for RBF tokens.\n     * @dev     This function is only callable by the PRICE_MINT_AMOUNT_SETTER_ROLE.\n     * @param   _depositMintAmount amount of RBF tokens minted\n     */\n    function setMintAmount(\n        uint256 _depositMintAmount\n    ) public onlyRole(MINT_AMOUNT_SETTER_ROLE) {\n        require(depositAmount > 0, \"RBF: depositAmount must be greater than 0\");\n        depositMintAmount = _depositMintAmount;\n        emit DepositDataEvent(depositMintAmount);\n    }\n\n    /**\n     * @notice  Allows the manager to set the vault contract address.\n     * @dev     This function assigns the vault address, which interacts with the RBF contract.\n     * @param   _vault  The address of the vault to be set.\n     */\n    function setVault(address _vault) public onlyRole(MANAGER_ROLE) {\n        require(\n            _vault != address(0),\n            \"RBF: vaultAddr cannot be zero address\"\n        );\n        require(vault==address(0),\"RBF: vaultAddr already set\");\n        vault = _vault;\n        emit SetVault(_vault);\n    }\n\n\n    /**\n     * @notice  Sets the token metadata URI\n     * @dev     This function can only be called by an address with the `MANAGER_ROLE` role.\n     * @param   _tokenURI The new token URI (e.g., IPFS or a centralized server).\n     */\n    function setTokenURI(string memory _tokenURI) public onlyRole(MANAGER_ROLE) {\n        tokenURI=_tokenURI;\n        emit SetTokenURI(tokenURI);\n    }\n\n\n    /**\n     * @notice  Fetches the net asset value (NAV) of the vault's RBF tokens based on the asset price.\n     * @dev     This function calculates the NAV of the RBF tokens held by vault by fetching the latest price.\n     * @return  uint256  The NAV in terms of the asset token's value.\n     */\n    function getAssetsNav() public view returns (uint256) {\n        int256 lastPrice = getLatestPrice();\n        uint256 amount = balanceOf(vault);\n        uint256 indexDecimals = 10 ** decimals();\n        return (amount * uint256(lastPrice)) / indexDecimals;\n    }\n\n    /**\n     * @notice  Fetches the latest price of the asset token from the price feed.\n     * @dev     This function interacts with the price feed contract to get the latest price of the asset token.\n     * @return  int256  The latest price of the asset token.\n     */\n    function getLatestPrice() public view returns (int256) {\n        (\n            uint80 roundId,\n            int256 price,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n        require(\n            (roundId > 0 &&\n                price >= 0 &&\n                startedAt > 0 &&\n                updatedAt > 0 &&\n                answeredInRound > 0),\n            \"Invalid price data\"\n        );\n        return price;\n    }\n\n    /**\n     * @notice  Overrides the decimals function to return 6 decimals for the RBF token.\n     *          Same as Stablecoins decimals\n     * @dev     Sets the precision of the RBF token to 6 decimals.\n     * @return  uint8  The number of decimals for the RBF token.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n    function _dividend(\n        uint256 rbfAmount,\n        uint256 totalSupply,\n        uint256 totalDividend,\n        address receiver\n    ) internal {\n        uint256 dividendAmount = (rbfAmount * totalDividend) / totalSupply;\n        require(\n            dividendAmount > 0,\n            \"RBF: dividendAmount must greater than zero\"\n        );\n        SafeERC20.safeTransferFrom(\n            IERC20(assetToken),\n            dividendTreasury,\n            receiver,\n            dividendAmount\n        );\n    }\n\n}"
    },
    "contracts/v1/rbf/RBFRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interface/IRBFFactory.sol\";\nimport \"../interface/IEscrowFactory.sol\";\nimport \"../interface/IPriceFeedFactory.sol\";\nimport \"../interface/IRBFRouter.sol\";\nimport \"../common/Escrow.sol\";\nimport \"./RBF.sol\";\n\n/**\n * @author  Accelerate Finance\n * @title   RBFRouter\n * @dev     Router contract for deploying RBF contracts and managing their settings.\n * @notice  This contract facilitates the creation and management of RBF contracts, handling escrow and price feed deployment.\n */\ncontract RBFRouter is IRBFRouter, Ownable {\n    // Struct to store RBF contract information\n    struct RBFInfo {\n        uint256 createdAt; // Timestamp when the RBF contract was created\n        address rbf; // Address of the deployed RBF contract\n        address rbfProxyAdmin; // Address of the RBF proxy admin\n        address rbfImpl; // Address of the RBF implementation contract\n        address dividendTreasury; // Address of the dividend treasury escrow contract\n        address priceFeed; // Address of the associated price feed contract\n    }\n\n    // Struct to hold data for deploying an RBF contract\n    struct RBFDeployData {\n        uint64 rbfId; // Unique identifier for the RBF contract\n        string name; //Name of the RBF token\n        string symbol; //Symbol of the RBF token\n        address assetToken; //Address of the asset backing the RBF\n        address depositTreasury; //Address of the deposit treasury\n        address deployer; //Address of the deployer\n        address manager; //Address of the RBF and PriceFeed manager\n        address guardian; //Guardian address for security proxy update\n    }\n\n    // Minimum number of valid signatures required for deployment\n    uint256 public threshold;\n    // Nonce for tracking RBF contract deployments\n    uint64 public rbfNonce;\n    // Immutable factory contract addresses for RBF, escrow, and price feeds\n    IRBFFactory public immutable rbfFactory;\n    IEscrowFactory public immutable escrowFactory;\n    IPriceFeedFactory public immutable priceFeedFactory;\n    // Mapping of RBF ID to its corresponding contract information\n    mapping(uint64 => RBFInfo) private rbfs;\n    // Mapping to track whitelisted addresses authorized to sign transactions\n    mapping(address => bool) public whiteListed;\n    address[] public whiteLists;\n\n    /**\n     * @notice Constructor to initialize the router with necessary parameters.\n     * @dev Sets up the factories for RBF, escrow, and price feed while initializing the whitelist and threshold.\n     * @param _whiteLists Array of addresses that are whitelisted for signing transactions.\n     * @param _threshold Minimum number of valid signatures required.\n     * @param _rbfFactory Address of the RBF factory.\n     * @param _escrowFactory Address of the escrow factory.\n     * @param _priceFeedFactory Address of the price feed factory.\n     */\n    constructor(\n        address[] memory _whiteLists,\n        uint256 _threshold,\n        address _rbfFactory,\n        address _escrowFactory,\n        address _priceFeedFactory\n    ) Ownable() {\n        require(_whiteLists.length > 0, \"whiteLists must not be empty\");\n        whiteLists = _whiteLists;\n        for (uint256 i = 0; i < _whiteLists.length; i++) {\n            whiteListed[_whiteLists[i]] = true;\n        }\n        require(_threshold > 0, \"threshold must >0\");\n        threshold = _threshold;\n        require(_rbfFactory != address(0), \"rbfFactory must not be zero\");\n        rbfFactory = IRBFFactory(_rbfFactory);\n        require(_escrowFactory != address(0), \"escrowFactory must not be zero\");\n        escrowFactory = IEscrowFactory(_escrowFactory);\n        require(\n            _priceFeedFactory != address(0),\n            \"priceFeedFactory must not be zero\"\n        );\n        priceFeedFactory = IPriceFeedFactory(_priceFeedFactory);\n    }\n\n\n    /**\n     * @notice  Updates the whitelist of authorized signers and the signature threshold.\n     * @dev     Only the contract owner can call this function. It first clears the existing whitelist,\n     *          then sets the new whitelist addresses and updates the required signature threshold.\n     * @param   _whiteLists  Array of new addresses to be whitelisted.\n     * @param   _threshold  Minimum number of valid signatures required for verification.\n     */\n    function setWhiteListsAndThreshold(\n        address[] memory _whiteLists,\n        uint256 _threshold\n    ) public onlyOwner {\n        require(_whiteLists.length > 0, \"whiteLists must not be empty\");\n        require(_threshold > 0, \"threshold must not be zero\");\n        // Remove existing whitelist addresses\n        uint oldLen=whiteLists.length;\n        for (uint i = 0; i < oldLen; i++) {\n            whiteListed[whiteLists[i]] = false;\n        }\n\n        // Update whitelist addresses\n        whiteLists = _whiteLists;\n        uint newLen=_whiteLists.length;\n        for (uint256 i = 0; i < newLen; i++) {\n            whiteListed[_whiteLists[i]] = true;\n        }\n        // Update the required signature threshold\n        threshold = _threshold;\n\n        emit SetWhiteListsAndThreshold(_whiteLists, _threshold);\n    }\n\n    /**\n     * @notice  Deploys a new RBF contract after verifying signatures.\n     * @dev     Decodes the deployment data, verifies signatures, and deploys the RBF contract along with escrow and price feed.\n     * @param   deployData  Encoded data containing deployment parameters.\n     * @param   signatures  Array of signatures for verification.\n     */\n    function deployRBF(\n        bytes memory deployData,\n        bytes[] memory signatures\n    ) public {\n        _verifySign(deployData, signatures);\n\n        RBFDeployData memory rbfDeployData = abi.decode(\n            deployData,\n            (RBFDeployData)\n        );\n        require(rbfDeployData.rbfId == rbfNonce, \"RBFRouter:Invalid rbfId\");\n        require(\n            rbfDeployData.deployer == msg.sender,\n            \"RBFRouter:Invalid deployer\"\n        );\n        rbfNonce++;\n        address dividendTreasury = escrowFactory.newEscrow(address(this));\n        address pricerFeed = priceFeedFactory.newPriceFeed(\n            rbfDeployData.manager\n        );\n        RBFInitializeData memory data = RBFInitializeData({\n            name: rbfDeployData.name,\n            symbol: rbfDeployData.symbol,\n            assetToken: rbfDeployData.assetToken,\n            depositTreasury: rbfDeployData.depositTreasury,\n            dividendTreasury: dividendTreasury,\n            priceFeed: pricerFeed,\n            manager: rbfDeployData.manager\n        });\n        (address rbf, address rbfProxyAdmin, address rbfImpl) = rbfFactory\n            .newRBF(data, rbfDeployData.guardian);\n        rbfs[rbfDeployData.rbfId] = RBFInfo(\n            block.timestamp,\n            rbf,\n            rbfProxyAdmin,\n            rbfImpl,\n            address(dividendTreasury),\n            address(pricerFeed)\n        );\n        Escrow(dividendTreasury).approveMax(rbfDeployData.assetToken, rbf);\n        Escrow(dividendTreasury).rely(address(rbf));\n        Escrow(dividendTreasury).deny(address(this));\n        RBF(rbf).transferOwnership(msg.sender);\n        emit DeployRBFEvent(\n            rbfDeployData.rbfId,\n            pricerFeed,\n            rbf,\n            dividendTreasury\n        );\n    }\n\n    function _verifySign(\n        bytes memory deployData,\n        bytes[] memory signatures\n    ) internal view {\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(\n            keccak256(deployData)\n        );\n        uint256 validSignatures = 0;\n        for (uint256 i = 0; i < signatures.length; i++) {\n            address signer = recoverSigner(ethSignedMessageHash, signatures[i]);\n            require(whiteListed[signer], \"RBFRouter:Invalid Signer\");\n            validSignatures++;\n        }\n        require(validSignatures >= threshold, \"RBFRouter:Invalid Threshold\");\n    }\n\n    /**\n     * @notice  Retrieves information about a deployed RBF contract.\n     * @param   rbfId  rbfId The unique identifier of the RBF contract.\n     * @return  RBFInfo  The corresponding RBFInfo struct.\n     */\n    function getRBFInfo(uint64 rbfId) public view returns (RBFInfo memory) {\n        return rbfs[rbfId];\n    }\n\n    /**\n     * @notice  Returns the length of the whiteLists array.\n     * @dev     This function is used to get the length of the whiteLists array.\n     * @return  uint256  The length of the whiteLists array.\n     */\n    function getWhiteListsLen() public view returns (uint256) {\n        return whiteLists.length;\n    }\n\n\n    function recoverSigner(\n        bytes32 ethSignedMessageHash,\n        bytes memory signature\n    ) internal pure returns (address) {\n        require(signature.length == 65, \"RBFRouter:Invalid signature length\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        //  r, s, v\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return ecrecover(ethSignedMessageHash, v, r, s);\n    }\n\n    function getEthSignedMessageHash(\n        bytes32 messageHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    messageHash\n                )\n            );\n    }\n}"
    },
    "contracts/v1/vault/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../interface/AggregatorV3Interface.sol\";\nimport \"../interface/IVault.sol\";\nimport \"../rbf/RBF.sol\";\n\n// Struct for initializing the Vault contract with multiple parameters\nstruct VaultInitializeData {\n    string name; // Vault token name\n    string symbol; // Vault token symbol\n    address assetToken;\n    address rbf;\n    uint256 maxSupply;\n    uint256 subStartTime;\n    uint256 subEndTime;\n    uint256 duration;\n    uint256 fundThreshold;\n    uint256 financePrice;\n    uint256 minDepositAmount;\n    uint256 manageFee;\n    address manager;\n    address feeReceiver;\n    address dividendTreasury;\n    address[] whitelists;\n}\n\n/**\n * @author  Accelerate Finance\n * @title   Vault\n * @dev     A contract for handling deposit and minting of vault tokens, managing dividends, and controlling access by the manager.\n * @notice  This contract allows deposits in an underlying asset token and mints a corresponding amount of Vault tokens based on the deposit and the financePrice. It also supports dividend distribution and fee management by manager.\n */\ncontract Vault is\n    IVault,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable\n    \n{\n    bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n    uint256 public constant BPS_DENOMINATOR = 10_000;\n    uint256 public constant FINANCE_PRICE_DENOMINATOR = 10 ** 8;\n    // Address of the RBF contract\n    address public rbf;\n    // Address of the asset token that users will deposit (e.g., USDC)\n    address public assetToken;\n    // Address to receive the management fees\n    address public feeReceiver;\n    // Address where dividend funds are held for distribution\n    address public dividendTreasury;\n    // Maximum supply of Vault tokens\n    uint256 public maxSupply;\n    // Start time of the subscription period\n    uint256 public subStartTime;\n    //End time of the subscription period\n    uint256 public subEndTime;\n    // Duration for the investment period\n    uint256 public duration;\n    // Threshold for the fundraising, in basis points\n    uint256 public fundThreshold;\n    // Management fee taken from deposit\n    uint256 public manageFee;\n    // Minimum amount required to deposit into the Vault\n    uint256 public minDepositAmount;\n    // Multiplier to adjust decimals between assetToken and Vault token\n    uint256 public decimalsMultiplier;\n    // Address of the vault manager\n    address public manager;\n    // Total amount of assets in the Vault\n    uint256 public assetBalance;\n    // Accumulated management fees\n    uint256 public manageFeeBalance;\n    // End time of the Vault, set after fundraising\n    uint256 public endTime;\n    // Finance price\n    uint256 public financePrice;\n    // Mapping to check if an address is onChainWLMap\n    mapping(address => bool) public onChainWLMap;\n    // List of onChainWL addresses allowed to interact with the Vault onChain\n    address[] public onChainWL;\n     // Mapping to check if an address is offChainWLMap\n    mapping(address => bool) public offChainWLMap;\n    // List of offChainWL addresses allowed to interact with the Vault offChain\n    address[] public offChainWL;\n\n\n    modifier onlyOnChainWL(address _address) {\n        require(onChainWLMap[_address], \"Vault: you are not in onChainWL\");\n        _;\n    }\n\n    modifier onlyOffChainWL(address _address) {\n        require(offChainWLMap[_address], \"Vault: you are not in offChainWL\");\n        _;\n    }\n\n    /**\n     * @notice  Initializes the Vault contract with given parameters.\n     * @dev     This function sets the vault's basic parameters and ensures valid input values.\n     * @param   data Struct containing initialization parameters.\n     */\n    function initialize(VaultInitializeData memory data) public initializer {\n        __ERC20_init(data.name, data.symbol);\n        __Ownable_init();\n\n        require(\n            data.assetToken != address(0),\n            \"Vault: Invalid assetToken address\"\n        );\n        assetToken = data.assetToken;\n        require(data.rbf != address(0), \"Vault: Invalid rbf address\");\n        rbf = data.rbf;\n        require(data.maxSupply > 0, \"Vault: Invalid maxSupply\");\n        maxSupply = data.maxSupply;\n        require(data.subStartTime < data.subEndTime, \"Vault: Invalid subTime\");\n        subStartTime = data.subStartTime;\n        subEndTime = data.subEndTime;\n        require(data.duration > 0, \"Vault: Invalid duration\");\n        duration = data.duration;\n        require(\n            data.fundThreshold > 0 && data.fundThreshold <= BPS_DENOMINATOR,\n            \"Vault: Invalid fundThreshold\"\n        );\n        fundThreshold = data.fundThreshold;\n        require(data.financePrice > 0, \"Vault: Invalid financePrice\");\n        financePrice = data.financePrice;\n        require(data.minDepositAmount > 0 && data.minDepositAmount<= (data.financePrice*data.maxSupply/FINANCE_PRICE_DENOMINATOR), \"Vault: Invalid minDepositAmount\");\n        minDepositAmount = data.minDepositAmount;\n        require(\n            data.manageFee <= BPS_DENOMINATOR,\n            \"Vault: Invalid managerFee\"\n        );\n        manageFee = data.manageFee;\n        require(data.manager != address(0), \"Vault: Invalid manager\");\n        manager = data.manager;\n        require(\n            data.feeReceiver != address(0),\n            \"Vault: Invalid feeReceiver address\"\n        );\n        feeReceiver = data.feeReceiver;\n        require(\n            data.dividendTreasury != address(0),\n            \"Vault: Invalid dividendTreasury address\"\n        );\n        dividendTreasury = data.dividendTreasury;\n        require(\n            (data.whitelists.length > 0) && (data.whitelists.length <= 100),\n            \"Vault: Invalid whitelists length\"\n        );\n        onChainWL = data.whitelists;\n        for (uint256 i = 0; i < data.whitelists.length; i++) {\n            onChainWLMap[data.whitelists[i]] = true;\n        }\n        decimalsMultiplier =\n            10 **\n                (decimals() -\n                    IERC20MetadataUpgradeable(data.assetToken).decimals());\n\n        _grantRole(DEFAULT_ADMIN_ROLE, data.manager);\n        _grantRole(MANAGER_ROLE, data.manager);\n    }\n\n    /**\n     * @notice  Deposits assets into the vault during the subscription period.\n     * @dev     Ensures that deposits meet the minimum requirement and fall within the allowed period.\n     * @param   assets The amount of assets to deposit.\n     * @return  uint256 The amount of shares minted in exchange for the deposit.\n     */\n    function deposit(\n        uint256 assets\n    ) public virtual onlyOnChainWL(msg.sender) nonReentrant returns (uint256) {\n        require(assets >= minDepositAmount, \"Vault: deposit less than min\");\n        require(\n            block.timestamp >= subStartTime && block.timestamp <= subEndTime,\n            \"Vault: Invalid time\"\n        );\n        uint256 manageFeeAmount = (assets * manageFee) / BPS_DENOMINATOR;\n        manageFeeBalance = manageFeeBalance + manageFeeAmount;\n        assetBalance = assetBalance + assets;\n        SafeERC20.safeTransferFrom( \n            IERC20(assetToken),\n            msg.sender,\n            address(this),\n            assets + manageFeeAmount\n        );\n        uint256 shares = _getMintAmountForPrice(assets);\n        require(\n            totalSupply() + shares <= maxSupply,\n            \"Vault: maxSupply exceeded\"\n        );\n        _mint(msg.sender, shares);\n        emit DepositEvent(msg.sender,assets,manageFeeAmount,shares);\n        return shares;\n    }\n\n    /**\n     * @notice Allows whitelisted users to redeem their shares for underlying assets.\n     * @dev Users can redeem only after the subscription period ends and if the\n     *      fund threshold is not met. The function burns the user's shares,\n     *      calculates the corresponding asset amount, and transfers assets back\n     *      to the user including the manager's fee.\n     * @return The total amount of assets transferred to the user.\n     */\n    function redeem()\n        public\n        virtual\n        onlyOnChainWL(msg.sender) nonReentrant\n        returns (uint256)\n    {\n        require(block.timestamp >= subEndTime, \"Vault: Invalid time\");\n        require(\n            (maxSupply * fundThreshold) / BPS_DENOMINATOR > totalSupply(),\n            \"Vault: not allowed withdraw\"\n        );\n        uint256 shares = balanceOf(msg.sender);\n        uint256 assetAmount = _getAssetAmountForVault(shares);\n        _spendAllowance(msg.sender, address(this), shares);\n        _burn(msg.sender, shares);\n        uint256 feeAmount = (assetAmount * manageFee) / BPS_DENOMINATOR;\n        manageFeeBalance = manageFeeBalance - feeAmount;\n        assetBalance = assetBalance - assetAmount;\n        SafeERC20.safeTransfer(\n            IERC20(assetToken),\n            msg.sender,\n            assetAmount + feeAmount\n        );\n        emit FundFailRedeem(msg.sender,shares, assetAmount, feeAmount);\n        return assetAmount + feeAmount;\n    }\n\n\n    /**\n     * @notice  OffChain Deposits Mint into the vault during the subscription period \n     * @dev     Ensures that deposits meet the minimum requirement and fall within the allowed period.\n     * @param   receiver  The address of the recipient of the minted shares.\n     * @param   amount    The amount of vault tokens to be minted.\n     */\n    function offChainDepositMint(address receiver,uint256 amount) public onlyRole(MANAGER_ROLE) {\n        require(_getAssetAmountForVault(amount) >= minDepositAmount, \"Vault: OffChain deposit less than min\");\n        require(\n            block.timestamp >= subStartTime && block.timestamp <= subEndTime,\n            \"Vault: Invalid time\"\n        );\n        require(\n            totalSupply() + amount <= maxSupply,\n            \"Vault: maxSupply exceeded\"\n        );\n        require(offChainWLMap[receiver], \"Vault:OffChain receiver are not in offChainWL\");\n        _mint(receiver, amount);\n        emit OffChainDepositEvent(msg.sender,receiver,amount);\n    }\n\n\n    /**\n     * @notice  redemption to be serviced off chain\n     * @dev Users can redeem only after the subscription period ends and if the\n     *      fund threshold is not met. The function burns the user's shares,\n     *      calculates the corresponding asset amount and transfer to user offChain.\n     */\n    function offChainRedeem() public onlyOffChainWL(msg.sender){\n        require(block.timestamp >= subEndTime, \"Vault: Invalid time\");\n        require(\n            (maxSupply * fundThreshold) / BPS_DENOMINATOR > totalSupply(),\n            \"Vault: not allowed withdraw\"\n        );\n        uint256 shares = balanceOf(msg.sender);\n        _spendAllowance(msg.sender, address(this), shares);\n        _burn(msg.sender, shares);\n        emit OffChainRedeemEvent(msg.sender,shares);\n    }\n\n    /**\n     * @notice Allows the manager to withdraw accumulated management fees.\n     * @dev The function ensures that withdrawals are only possible after the\n     *      subscription period ends and if the fundraising threshold is met.\n     *      The entire balance of management fees is transferred to the designated\n     *      fee receiver.\n     */\n    function withdrawManageFee() public onlyRole(MANAGER_ROLE) nonReentrant{\n        require(endTime != 0, \"Vault: Invalid endTime\");\n        require(block.timestamp >= subEndTime, \"Vault: Invalid time\");\n        require(\n            (maxSupply * fundThreshold) / BPS_DENOMINATOR <= totalSupply(),\n            \"Vault: not allowed withdraw\"\n        );\n        uint256 feeAmount = manageFeeBalance;\n        manageFeeBalance = 0;\n        SafeERC20.safeTransfer(IERC20(assetToken), feeReceiver, feeAmount);\n    }\n\n    /**\n     * @notice Executes an investment strategy by depositing assets into the RBF contract.\n     * @dev This function ensures that the asset amount does not exceed the vaults balance.\n     *      It also verifies that fundraising is either complete or has met the required\n     *      threshold before proceeding. The function approves the asset transfer and\n     *      deposits the assets into the RBF contract.\n     */\n    function execStrategy() public onlyRole(MANAGER_ROLE) nonReentrant {\n        require(assetBalance>0,\"Vault: assetBalance is zero\");\n        require(\n            maxSupply == totalSupply() ||\n                (block.timestamp >= subEndTime &&\n                    (maxSupply * fundThreshold) / BPS_DENOMINATOR <=\n                    totalSupply()),\n            \"Vault: fundraising fail\"\n        );\n        if (endTime <= 0) {\n            endTime = block.timestamp + duration;\n        }\n        uint256 depositAmount=assetBalance;\n        assetBalance=0;\n        bool authRes = IERC20(assetToken).approve(rbf, depositAmount);\n        require(authRes, \"Vault: assetToken approve error\");\n        RBF(rbf).requestDeposit(depositAmount);\n        emit ExecStrategyEvent(depositAmount);\n    }\n\n    /**\n     * @notice Adds an address to the whitelist, allowing it to participate in the vault.\n     * @dev Only the contract owner can add addresses to the whitelist. Ensures that an address\n     *      is not already whitelisted and that the whitelist does not exceed 100 entries.\n     * @param whitelistAddr The address to be added to the whitelist.\n     */\n    function addToOnChainWL(\n        address whitelistAddr\n    ) public onlyRole(MANAGER_ROLE) {\n        require(\n            block.timestamp <= subEndTime,\n            \"Vault: Invalid time\"\n        );\n        require(\n            !onChainWLMap[whitelistAddr],\n            \"Vault: Address is already onChainWL\"\n        );\n        require(!offChainWLMap[whitelistAddr], \"Vault: Address is already offChainWL\");\n        require(onChainWL.length < 100, \"Vault: Whitelist is full\");\n        onChainWLMap[whitelistAddr] = true;\n        onChainWL.push(whitelistAddr);\n    }\n\n    /**\n     * @notice Removes an address from the whitelist, preventing further participation in the vault.\n     * @dev Only the contract owner can remove addresses from the whitelist. Ensures the address\n     *      is currently whitelisted before proceeding.\n     * @param whitelistAddr The address to be removed from the whitelist.\n     */\n    function removeFromOnChainWL(\n        address whitelistAddr\n    ) public onlyRole(MANAGER_ROLE) {\n        require(\n            block.timestamp <= subEndTime,\n            \"Vault: Invalid time\"\n        );\n        require(\n            onChainWLMap[whitelistAddr],\n            \"Vault: Address is not in the whitelist\"\n        );\n        require(balanceOf(whitelistAddr)<=0, \"Vault: Address has balance\");\n        onChainWLMap[whitelistAddr] = false;\n        for (uint256 i = 0; i < onChainWL.length; i++) {\n            if (onChainWL[i] == whitelistAddr) {\n                onChainWL[i] = onChainWL[onChainWL.length - 1];\n                onChainWL.pop();\n                break;\n            }\n        }\n    }\n\n\n     /**\n      * @notice  Adds an address to the OffChain Whitelist, allowing it to participate in the vault offChain.\n      * @dev     This function is only callable by the manager of the vault.\n      * @param   whitelistAddr  The address to be added to the OffChain Whitelist.\n      */\n     function addToOffChainWL(\n        address whitelistAddr\n    ) public onlyRole(MANAGER_ROLE) {\n        require(\n            block.timestamp <= subEndTime,\n            \"Vault: Invalid time\"\n        );\n        require(\n            !onChainWLMap[whitelistAddr],\n            \"Vault: Address is already onChainWL\"\n        );\n        require(!offChainWLMap[whitelistAddr], \"Vault: Address is already offChainWL\");\n        require(offChainWL.length < 100, \"Vault: Whitelist is full\");\n        offChainWLMap[whitelistAddr] = true;\n        offChainWL.push(whitelistAddr);\n    }\n\n\n\n    /**\n     * @notice  Removes an address from the OffChain whitelist, preventing further participation in the vault.\n     * @dev     This function can only be called by the manager of the vault.\n     * @param   whitelistAddr   The address to be removed from the OffChain whitelist.\n     */\n    function removeFromOffChainWL(\n        address whitelistAddr\n    ) public onlyRole(MANAGER_ROLE) {\n        require(\n            block.timestamp <= subEndTime,\n            \"Vault: Invalid time\"\n        );\n        require(\n            offChainWLMap[whitelistAddr],\n            \"Vault: Address is not in the offChain whitelist\"\n        );\n        require(balanceOf(whitelistAddr)<=0, \"Vault: Address has balance\");\n        offChainWLMap[whitelistAddr] = false;\n        for (uint256 i = 0; i < offChainWL.length; i++) {\n            if (offChainWL[i] == whitelistAddr) {\n                offChainWL[i] = offChainWL[offChainWL.length - 1];\n                offChainWL.pop();\n                break;\n            }\n        }\n    }\n\n\n    //  todo\n    //  The current project is designed primarily for small-scale whitelist-based fundraising.\n    //  Dividend distribution is handled via on-chain whitelist snapshots. \n    //  In the future, the platform will be opened to the public, and the distribution mechanism will be updated to a MasterChef-like model.\n    /**\n     * @notice Distributes dividends to whitelisted users based on their shareholding.\n     * @dev The function calculates the dividend amount for each whitelisted user and transfers\n     *      the corresponding amount. Only users with a nonzero balance receive dividends.\n     */\n    function dividend() public onlyRole(MANAGER_ROLE) nonReentrant {\n        uint256 totalDividend = IERC20(assetToken).balanceOf(dividendTreasury);\n        require(totalDividend > 0, \"Vault: No dividend to pay\");\n        uint256 totalSupply = totalSupply();\n        require(totalSupply > 0, \"Vault: No rbf to pay\");\n        for (uint8 i = 0; i < onChainWL.length; i++) {\n            if (onChainWLMap[onChainWL[i]]) {\n                if (balanceOf(onChainWL[i]) != 0) {\n                    _dividend(\n                        balanceOf(onChainWL[i]),\n                        totalSupply,\n                        totalDividend,\n                        onChainWL[i]\n                    );\n                }\n            }\n        }\n        for (uint8 i=0; i<offChainWL.length; i++){\n            if (offChainWLMap[offChainWL[i]]){\n                if (balanceOf(offChainWL[i]) != 0) {\n                    _dividend(\n                        balanceOf(offChainWL[i]),\n                        totalSupply,\n                        totalDividend,\n                        offChainWL[i]\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the price of a single share in the vault.\n     * @dev The price is determined by fetching the NAV (Net Asset Value) from the RBF contract\n     *      and adjusting it according to the price feed's decimal format.\n     * @return The price of one share in the vault.\n     */\n    function price() public view returns (uint256) {\n        uint256 totalSupply = totalSupply();\n        uint256 nav = RBF(rbf).getAssetsNav();\n        return nav * (10**decimals())  / totalSupply;\n    }\n\n    /**\n     * @notice Returns the decimal precision of the vault token.\n     * @dev Overrides the default ERC20 decimals function and sets it to 6.\n     * @return The number of decimals used for the vault token.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n\n     /**\n     * @notice  Returns the length of the onChainWL array.\n     * @dev     This function is used to get the length of the onChainWL array.\n     * @return  uint256  The length of the onChainWL array.\n     */\n    function getOnChainWLLen() public view returns (uint256) {\n        return onChainWL.length;\n    }\n\n\n    /**\n     * @notice  Returns the length of the offChainWL array.\n     * @dev     This function is used to get the length of the offChainWL array.\n     * @return  uint256  The length of the offChainWL array.\n     */\n    function getOffChainWLLen() public view returns (uint256) {\n        return offChainWL.length;\n    }\n\n    /**\n     * @notice Transfers tokens from the caller to another address.\n     * @dev The function checks if the transfer is authorized before executing it.\n     *      It then updates the sender and receiver balances accordingly.\n     * @param to The recipient address.\n     * @param amount The amount of tokens to transfer.\n     * @return A boolean value indicating whether the transfer was successful.\n     */\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _checkTransferAuth(msg.sender, to);\n        bool success = super.transfer(to, amount);\n        return success;\n    }\n\n    /**\n     * @notice Transfers tokens from one address to another using an allowance mechanism.\n     * @dev The function ensures the sender is authorized to transfer on behalf of `from`.\n     *      It then deducts the allowance and transfers the specified amount.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address.\n     * @param amount The amount of tokens to transfer.\n     * @return A boolean value indicating whether the transfer was successful.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _checkTransferAuth(from, to);\n        bool success = super.transferFrom(from, to, amount);\n        return success;\n    }\n\n\n\n    function _dividend(\n        uint256 vaultTokenAmount,\n        uint256 totalSupply,\n        uint256 totalDividend,\n        address receipter\n    ) internal {\n        require(receipter != address(0), \"Vault: receipter can not be zero\");\n        uint256 dividendAmount = (vaultTokenAmount * totalDividend) /\n            totalSupply;\n        require(dividendAmount > 0, \"Vault: dividendAmount must bigger than zero\");\n        SafeERC20.safeTransferFrom(\n            IERC20(assetToken),\n            dividendTreasury,\n            receipter,\n            dividendAmount\n        );\n    }\n\n    function _checkTransferAuth(address from, address to) internal view {\n        require(endTime != 0, \"Vault: Invalid endTime\");\n        require(block.timestamp >= subEndTime, \"Vault: Invalid time\");\n        require(\n            (maxSupply * fundThreshold) / BPS_DENOMINATOR <= totalSupply(),\n            \"Vault: not allowed transfer\"\n        );\n        require(\n            (onChainWLMap[from]|| offChainWLMap[from]) && (onChainWLMap[to]|| offChainWLMap[to]),\n            \"Vault: transfer from and to must in onChainWL or offChainWL\"\n        );\n    }\n\n    function _getMintAmountForPrice(\n        uint256 depositAmount\n    ) internal view returns (uint256) {\n        require(financePrice > 0, \"Vault: financePrice must bigger than zero\");\n        uint256 rwaAmount = (_scaleUp(depositAmount) *\n            FINANCE_PRICE_DENOMINATOR) / financePrice;\n        return rwaAmount;\n    }\n    \n    function _getAssetAmountForVault(\n        uint256 vaultAmount\n    ) internal view returns (uint256) {\n        require(financePrice > 0, \"Vault: financePrice must bigger than zero\");\n        uint256 assetAmount = (_scaleDown(vaultAmount) * financePrice) /\n            FINANCE_PRICE_DENOMINATOR;\n        return assetAmount;\n    }\n\n    function _scaleUp(uint256 amount) internal view returns (uint256) {\n        return amount * decimalsMultiplier;\n    }\n\n    function _scaleDown(uint256 amount) internal view returns (uint256) {\n        return amount / decimalsMultiplier;\n    }\n\n}"
    },
    "contracts/v1/vault/VaultRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n    ___                         __                         __\n   /   |  _____  _____  ___    / /  ___    _____  ____ _  / /_  ___\n  / /| | / ___/ / ___/ / _ \\  / /  / _ \\  / ___/ / __ `/ / __/ / _ \\\n / ___ |/ /__  / /__  /  __/ / /  /  __/ / /    / /_/ / / /_  /  __/\n/_/  |_|\\___/  \\___/  \\___/ /_/   \\___/ /_/     \\__,_/  \\__/  \\___/\n\n*/\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../common/Escrow.sol\";\nimport \"./Vault.sol\";\nimport \"../interface/IEscrowFactory.sol\";\nimport \"../interface/IVaultFactory.sol\";\nimport \"../interface/IVaultRouter.sol\";\nimport \"../rbf/RBF.sol\";\n\n/**\n * @author  Accelerate Finance\n * @title   VaultRouter\n * @dev     Manages the deployment of vaults and associated escrow contracts.\n * @notice  This contract allows users to deploy new vaults and retrieve vault information.\n */\ncontract VaultRouter is Ownable,IVaultRouter {\n    struct VaultInfo {\n        uint256 createdAt;\n        address vault;\n        address vaultProxyAdmin;\n        address vaultImpl;\n        address dividendTreasury;\n    }\n\n    // Immutable reference to the escrow factory contract.\n    IEscrowFactory public immutable escrowFactory;\n    // Immutable reference to the vault factory contract.\n    IVaultFactory public immutable vaultFactory;\n    // Counter for tracking the latest deployed vault ID.\n    uint64 public vaultNonce;\n    // Mapping from vault ID to its VaultInfo struct.\n    mapping(uint64 => VaultInfo) private vaults;\n    // Mapping to check if an RBF vault has already been deployed.\n    mapping(address => bool) public rbfVaultExist;\n\n    /**\n     * @dev Constructor initializes the VaultRouter with escrow and vault factory addresses.\n     * @param _escrowFactory Address of the escrow factory contract.\n     * @param _vaultFactory Address of the vault factory contract.\n     */\n    constructor(address _escrowFactory, address _vaultFactory) Ownable() {\n        escrowFactory = IEscrowFactory(_escrowFactory);\n        vaultFactory = IVaultFactory(_vaultFactory);\n    }\n\n    /**\n     * @dev Deploys a new vault using provided deployment data.\n     * @param vaultDeployData Struct containing vault initialization parameters.\n     * @notice Only the owner of the associated RBF contract can deploy a vault.\n     */\n    function deployVault(VaultDeployData memory vaultDeployData) public {\n        require(vaultDeployData.vaultId == vaultNonce, \"Invalid vaultId\");\n        uint64 vaultId=vaultDeployData.vaultId;\n        vaultNonce++;\n\n        require(RBF(vaultDeployData.rbf).owner() == msg.sender,\"only rbf owner can deploy vault\");\n        require(!rbfVaultExist[vaultDeployData.rbf],\"rbf vault already exist\");\n        rbfVaultExist[vaultDeployData.rbf]=true;\n        address dividendTreasury = escrowFactory.newEscrow(address(this));\n\n        VaultInitializeData memory data=VaultInitializeData({\n            name: vaultDeployData.name,\n            symbol: vaultDeployData.symbol,\n            assetToken: vaultDeployData.assetToken,\n            rbf: vaultDeployData.rbf,\n            maxSupply: vaultDeployData.maxSupply,\n            subStartTime: vaultDeployData.subStartTime,\n            subEndTime: vaultDeployData.subEndTime,\n            duration: vaultDeployData.duration,\n            fundThreshold: vaultDeployData.fundThreshold,\n            financePrice:vaultDeployData.financePrice,\n            minDepositAmount: vaultDeployData.minDepositAmount,\n            manageFee: vaultDeployData.manageFee,\n            manager: vaultDeployData.manager,\n            feeReceiver:vaultDeployData.feeReceiver,\n            dividendTreasury: dividendTreasury,\n            whitelists:vaultDeployData.whitelists\n        });\n\n        (address vault,address vaultProxyAdmin,address vaultImpl) = vaultFactory.newVault(data,vaultDeployData.guardian);\n         vaults[vaultId] = VaultInfo(\n            block.timestamp,\n            vault,\n            vaultProxyAdmin,\n            vaultImpl,\n            dividendTreasury\n        );\n        Escrow(dividendTreasury).approveMax(vaultDeployData.assetToken, vault);\n        Escrow(dividendTreasury).rely(address(vault));\n        Escrow(dividendTreasury).deny(address(this));\n        Vault(vault).transferOwnership(msg.sender);\n        emit DeployVaultEvent(vaultId, vault, dividendTreasury);\n    }\n\n    /**\n     * @dev Retrieves information about a deployed vault.\n     * @param vaultId The unique ID of the vault.\n     * @return VaultInfo struct containing details of the vault.\n     */\n    function getVaultInfo(\n        uint64 vaultId\n    ) public view returns (VaultInfo memory) {\n        VaultInfo memory vault = vaults[vaultId];\n        return vault;\n    }\n}"
    },
    "contracts/v2/creation/Creation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"../interfaces/ICreation.sol\";\nimport \"../factories/VaultFactory.sol\";\nimport \"../factories/TokenFactory.sol\";\nimport \"../factories/FundFactory.sol\";\nimport \"../factories/YieldFactory.sol\";\n\ncontract Creation is ICreation, Ownable {\n    VaultFactory public vaultFactory;\n    TokenFactory public tokenFactory;\n    FundFactory public fundFactory;\n    YieldFactory public yieldFactory;\n    \n    // User-supplied initialization parameter struct (excluding context contract addresses)\n    struct VaultUserParams {\n        address validator;\n        bool whitelistEnabled;\n        address[] initialWhitelist;\n    }\n    \n    struct TokenUserParams {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n    \n    struct FundUserParams {\n        uint256 startTime;\n        uint256 endTime;\n        address assetToken;\n        uint256 maxSupply;\n        uint256 softCap;\n        uint256 sharePrice;\n        uint256 minDepositAmount;\n        uint256 manageFeeBps;\n        address fundingReceiver;\n        address manageFeeReceiver;\n        uint256 decimalsMultiplier;\n    }\n    \n    struct AccumulatedYieldUserParams {\n        address rewardToken;\n        address rewardManager;\n        address dividendTreasury;\n    }\n\n    // Project mapping: project name => project details\n    mapping(string => Project) public projects;\n    \n    // User project mapping: deployer => projectName[]\n    mapping(address => string[]) public userProjects;\n    \n    // Whitelist permission\n    mapping(address => bool) public whitelist;\n\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender], \"Creation: not whitelisted\");\n        _;\n    }\n\n    function addToWhitelist(address user) external onlyOwner {\n        whitelist[user] = true;\n    }\n    function removeFromWhitelist(address user) external onlyOwner {\n        whitelist[user] = false;\n    }\n\n    constructor(\n        address _vaultFactory,\n        address _tokenFactory,\n        address _fundFactory,\n        address _YieldFactory\n    ) {\n        vaultFactory = VaultFactory(_vaultFactory);\n        tokenFactory = TokenFactory(_tokenFactory);\n        fundFactory = FundFactory(_fundFactory);\n        yieldFactory = YieldFactory(_YieldFactory);\n        \n        // Ensure owner is set correctly\n        _transferOwnership(msg.sender);\n        whitelist[msg.sender] = true;\n    }\n    \n    // Implementation of the deployAll method in the interface\n    function deployAll(\n        string memory projectName,\n        uint256 vaultTemplateId,\n        bytes memory vaultInitData,\n        uint256 tokenTemplateId,\n        bytes memory tokenInitData,\n        uint256 fundTemplateId,\n        bytes memory fundInitData,\n        uint256 dividendTemplateId,\n        bytes memory dividendInitData\n    ) external override onlyWhitelisted returns (DeploymentResult memory result) {\n        // Parameter validation\n        require(bytes(projectName).length > 0, \"Creation: project name cannot be empty\");\n        require(bytes(projects[projectName].name).length == 0, \"Creation: project name already exists\");\n        \n        // Validate Vault initialization data\n        require(vaultInitData.length > 0, \"Creation: vault init data cannot be empty\");\n        try this.validateVaultInitData(vaultInitData) {\n            // Validation passed\n        } catch {\n            revert(\"Creation: invalid vault init data format\");\n        }\n        \n        // Validate Token initialization data\n        require(tokenInitData.length > 0, \"Creation: token init data cannot be empty\");\n        try this.validateTokenInitData(tokenInitData) {\n            // Validation passed\n        } catch {\n            revert(\"Creation: invalid token init data format\");\n        }\n        \n        // Validate Fund initialization data\n        require(fundInitData.length > 0, \"Creation: fund init data cannot be empty\");\n        try this.validateFundInitData(fundInitData) {\n            // Validation passed\n        } catch Error(string memory reason) {\n            revert(string(abi.encodePacked(reason)));\n        } catch {\n            revert(\"Creation: invalid fund init data format\");\n        }\n        \n        // Validate Dividend initialization data\n        require(dividendInitData.length > 0, \"Creation: dividend init data cannot be empty\");\n        try this.validateDividendInitData(dividendInitData) {\n            // Validation passed\n        } catch {\n            revert(\"Creation: invalid dividend init data format\");\n        }\n        // 1. Deploy Vault\n        address vault = vaultFactory.createVault(vaultTemplateId, vaultInitData);\n        require(vault != address(0), \"Creation: vault creation failed\");\n        \n        // 2. Deploy Token (requires vault parameter)\n        address token = tokenFactory.createToken(tokenTemplateId, vault, tokenInitData);\n        require(token != address(0), \"Creation: token creation failed\");\n        \n        // 3. Deploy Fund\n        address fund = fundFactory.createFund(fundTemplateId, vault, fundInitData);\n        require(fund != address(0), \"Creation: fund creation failed\");\n        \n        // 4. Deploy AccumulatedYield\n        address accumulatedYield = yieldFactory.createYield(\n            dividendTemplateId,\n            vault,\n            token,\n            dividendInitData\n        );\n        require(accumulatedYield != address(0), \"Creation: accumulatedYield creation failed\");\n        \n        // 5. Create project record\n        projects[projectName] = Project({\n            name: projectName,\n            vault: vault,\n            token: token,\n            fund: fund,\n            accumulatedYield: accumulatedYield,\n            createdAt: block.timestamp,\n            deployer: msg.sender\n        });\n        \n        userProjects[msg.sender].push(projectName);\n        \n        // 7. Construct return result\n        result = DeploymentResult({\n            vault: vault,\n            token: token,\n            fund: fund,\n            accumulatedYield: accumulatedYield\n        });\n        \n        emit ProjectCreated(projectName, vault, token, fund, accumulatedYield, msg.sender);\n        \n        return result;\n    }\n    \n    // Validate Vault initialization data format\n    function validateVaultInitData(bytes memory vaultInitData) external pure {\n        (address manager, address validator, bool whitelistEnabled, address[] memory initialWhitelist) =\n            abi.decode(vaultInitData, (address, address, bool, address[]));\n        \n        require(manager != address(0), \"Creation: vault manager cannot be zero address\");\n        require(validator != address(0), \"Creation: vault validator cannot be zero address\");\n        \n        // If whitelist is enabled, check initial whitelist\n        if (whitelistEnabled) {\n            require(initialWhitelist.length > 0, \"Creation: initial whitelist cannot be empty when whitelist is enabled\");\n            for (uint256 i = 0; i < initialWhitelist.length; i++) {\n                require(initialWhitelist[i] != address(0), \"Creation: whitelist address cannot be zero\");\n            }\n        }\n    }\n    \n    // Validate Token initialization data format\n    function validateTokenInitData(bytes memory tokenInitData) external pure {\n        (string memory name, string memory symbol, uint8 decimals) =\n            abi.decode(tokenInitData, (string, string, uint8));\n        \n        require(bytes(name).length > 0, \"Creation: token name cannot be empty\");\n        require(bytes(symbol).length > 0, \"Creation: token symbol cannot be empty\");\n        require(decimals <= 18, \"Creation: token decimals cannot exceed 18\");\n    }\n    \n    // Validate Fund initialization data format\n    function validateFundInitData(bytes memory fundInitData) external pure {\n        (\n            uint256 startTime,\n            uint256 endTime,\n            address assetToken,\n            uint256 maxSupply,\n            uint256 softCap,\n            uint256 sharePrice,\n            uint256 minDepositAmount,\n            uint256 manageFeeBps,\n            address fundingReceiver,\n            address manageFeeReceiver,\n            uint256 decimalsMultiplier,\n            address manager\n        ) = abi.decode(fundInitData, (uint256, uint256, address, uint256, uint256, uint256, uint256, uint256, address, address, uint256, address));\n        \n        require(startTime > 0, \"Creation: start time must be greater than 0\");\n        require(endTime > startTime, \"Creation: end time must be after start time\");\n        require(assetToken != address(0), \"Creation: asset token cannot be zero address\");\n        require(maxSupply > 0, \"Creation: max supply must be greater than 0\");\n        require(softCap > 0 && softCap <= maxSupply, \"Creation: soft cap must be greater than 0 and not exceed max supply\");\n        require(sharePrice > 0, \"Creation: share price must be greater than 0\");\n        require(minDepositAmount > 0, \"Creation: min deposit amount must be greater than 0\");\n        require(manageFeeBps <= 10000, \"Creation: manage fee cannot exceed 100%\");\n        require(fundingReceiver != address(0), \"Creation: funding receiver cannot be zero address\");\n        require(manageFeeReceiver != address(0), \"Creation: manage fee receiver cannot be zero address\");\n        require(decimalsMultiplier > 0, \"Creation: decimals multiplier must be greater than 0\");\n        require(manager != address(0), \"Creation: manager cannot be zero address\");\n    }\n    \n    // Validate Dividend initialization data format\n    function validateDividendInitData(bytes memory dividendInitData) external pure {\n        (address rewardToken, address rewardManager, address dividendTreasury) =\n            abi.decode(dividendInitData, (address, address, address));\n        \n        require(rewardToken != address(0), \"Creation: reward token cannot be zero address\");\n        require(rewardManager != address(0), \"Creation: reward manager cannot be zero address\");\n        require(dividendTreasury != address(0), \"Creation: dividend treasury cannot be zero address\");\n    }\n    \n    // Other interface methods\n    function setFactories(\n        address _vaultFactory,\n        address _tokenFactory,\n        address _fundFactory,\n        address _dividendFactory\n    ) external override onlyOwner {\n        vaultFactory = VaultFactory(_vaultFactory);\n        tokenFactory = TokenFactory(_tokenFactory);\n        fundFactory = FundFactory(_fundFactory);\n        yieldFactory = YieldFactory(_dividendFactory);\n        \n        emit FactoriesUpdated(_vaultFactory, _tokenFactory, _fundFactory, _dividendFactory);\n    }\n    \n    function getFactories() external view override returns (\n        address,\n        address,\n        address,\n        address\n    ) {\n        return (address(vaultFactory), address(tokenFactory), address(fundFactory), address(yieldFactory));\n    }\n    \n    function deployVault(uint256 templateId, bytes memory initData) external override returns (address vault) {\n        vault = vaultFactory.createVault(templateId, initData);\n        emit VaultCreated(vault);\n        return vault;\n    }\n    \n    function deployToken(uint256 templateId, address vault, bytes memory initData) external override returns (address token) {\n        token = tokenFactory.createToken(templateId, vault, initData);\n        emit TokenCreated(token);\n        return token;\n    }\n    \n    function deployFund(uint256 templateId, address vault, bytes memory initData) external override returns (address fund) {\n        fund = fundFactory.createFund(templateId, vault, initData);\n        emit FundCreated(fund);\n        return fund;\n    }\n    \n    function deployDividend(uint256 templateId, address vault, address vaultToken, bytes memory initData) external override returns (address dividend) {\n        dividend = yieldFactory.createYield(templateId, vault, vaultToken, initData);\n        emit YieldCreated(dividend);\n        return dividend;\n    }\n    \n    // Get project details by project name\n    function getProjectByName(string memory projectName) external view returns (Project memory) {\n        Project memory project = projects[projectName];\n        require(bytes(project.name).length > 0, \"Creation: project not found\");\n        return project;\n    }\n    \n    // Get all project details for a user\n    function getUserProjectDetails(address user) external view returns (Project[] memory) {\n        string[] memory projectNames = userProjects[user];\n        Project[] memory userProjectDetails = new Project[](projectNames.length);\n        for (uint256 i = 0; i < projectNames.length; i++) {\n            userProjectDetails[i] = projects[projectNames[i]];\n        }\n        return userProjectDetails;\n    }\n    \n    // Get all projects for a user (returns DeploymentResult array)\n    function getUserProjects(address user) external view override returns (DeploymentResult[] memory result) {\n        string[] memory projectNames = userProjects[user];\n        result = new DeploymentResult[](projectNames.length);\n        for (uint256 i = 0; i < projectNames.length; i++) {\n            Project memory project = projects[projectNames[i]];\n            result[i] = DeploymentResult({\n                vault: project.vault,\n                token: project.token,\n                fund: project.fund,\n                accumulatedYield: project.accumulatedYield\n            });\n        }\n        return result;\n    }\n} "
    },
    "contracts/v2/factories/FundFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IFactory.sol\";\n\ncontract FundFactory is IFundFactory, Ownable {\n    using Clones for address;\n    \n    mapping(uint256 => address) public templates;\n    uint256 public templateCount;\n    \n    function addTemplate(uint256 templateId, address template) external override onlyOwner {\n        require(template != address(0), \"FundFactory: invalid template\");\n        require(templates[templateId] == address(0), \"FundFactory: template already exists\");\n        \n        templates[templateId] = template;\n        if (templateId >= templateCount) {\n            templateCount = templateId + 1;\n        }\n        emit TemplateAdded(templateId, template);\n    }\n    \n    function createFund(uint256 templateId, address vault, bytes memory initData) external override returns (address fund) {\n        address template = templates[templateId];\n        require(template != address(0), \"FundFactory: template not found\");\n        \n        fund = template.clone();\n        \n        bytes memory fullInitData = abi.encodeWithSignature(\n            \"initiate(address,bytes)\",\n            vault, initData\n        );\n        \n        // (bool success, ) = fund.call(fullInitData);\n        // require(success, \"FundFactory: initialization failed\");\n        (bool success, bytes memory returndata) = fund.call(fullInitData);\n        if (!success) {\n            if (returndata.length > 0) {\n                //  reason \n                string memory reason;\n                assembly {\n                    returndata := add(returndata, 0x04)\n                }\n                reason = abi.decode(returndata, (string));\n                revert(string(abi.encodePacked(\"FundFactory: \", reason)));\n            } else {\n                revert(\"FundFactory: initialization failed\");\n            }\n        }\n        \n        emit FundCreated(templateId, fund, msg.sender);\n        \n        return fund;\n    }\n    \n    function getTemplate(uint256 templateId) external view override returns (address) {\n        return templates[templateId];\n    }\n    \n    function getTemplateCount() external view override returns (uint256) {\n        return templateCount;\n    }\n} "
    },
    "contracts/v2/factories/TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IFactory.sol\";\n\ncontract TokenFactory is ITokenFactory, Ownable {\n    using Clones for address;\n    \n    mapping(uint256 => address) public templates;\n    uint256 public templateCount;\n    \n    function addTemplate(uint256 templateId, address template) external override onlyOwner {\n        require(template != address(0), \"TokenFactory: invalid template\");\n        require(templates[templateId] == address(0), \"TokenFactory: template already exists\");\n        \n        templates[templateId] = template;\n        if (templateId >= templateCount) {\n            templateCount = templateId + 1;\n        }\n        emit TemplateAdded(templateId, template);\n    }\n    \n    function createToken(uint256 templateId, address vault, bytes memory initData) external override returns (address token) {\n        address template = templates[templateId];\n        require(template != address(0), \"TokenFactory: template not found\");\n        \n        token = template.clone();\n        \n        bytes memory fullInitData = abi.encodeWithSignature(\n            \"initiate(address,bytes)\",\n            vault, initData\n        );\n        \n        (bool success, ) = token.call(fullInitData);\n        require(success, \"TokenFactory: initialization failed\");\n        \n        emit TokenCreated(templateId, token, msg.sender);\n        \n        return token;\n    }\n    \n    function getTemplate(uint256 templateId) external view override returns (address) {\n        return templates[templateId];\n    }\n    \n    function getTemplateCount() external view override returns (uint256) {\n        return templateCount;\n    }\n} "
    },
    "contracts/v2/factories/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IFactory.sol\";\n\ncontract VaultFactory is IVaultFactory, Ownable {\n    using Clones for address;\n    \n    mapping(uint256 => address) public templates;\n    uint256 public templateCount;\n    \n    function addTemplate(uint256 templateId, address template) external override onlyOwner {\n        require(template != address(0), \"VaultFactory: invalid template\");\n        require(templates[templateId] == address(0), \"VaultFactory: template already exists\");\n        \n        templates[templateId] = template;\n        if (templateId >= templateCount) {\n            templateCount = templateId + 1;\n        }\n        \n        emit TemplateAdded(templateId, template);\n    }\n    \n    function createVault(uint256 templateId, bytes memory initData) external override returns (address vault) {\n        address template = templates[templateId];\n        require(template != address(0), \"VaultFactory: template not found\");\n        \n        vault = template.clone();\n        \n        bytes memory fullInitData = abi.encodeWithSignature(\n            \"initiate(bytes)\",\n            initData\n        );\n        \n        (bool success, ) = vault.call(fullInitData);\n        require(success, \"VaultFactory: initialization failed\");\n        \n        emit VaultCreated(templateId, vault, msg.sender);\n        \n        return vault;\n    }\n    \n    function getTemplate(uint256 templateId) external view override returns (address) {\n        return templates[templateId];\n    }\n    \n    function getTemplateCount() external view override returns (uint256) {\n        return templateCount;\n    }\n} "
    },
    "contracts/v2/factories/YieldFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IFactory.sol\";\n\ncontract YieldFactory is IYieldFactory, Ownable {\n    using Clones for address;\n    \n    mapping(uint256 => address) public templates;\n    uint256 public templateCount;\n    \n    function addTemplate(uint256 templateId, address template) external override onlyOwner {\n        require(template != address(0), \"YieldFactory: invalid template\");\n        require(templates[templateId] == address(0), \"YieldFactory: template already exists\");\n        \n        templates[templateId] = template;\n        if (templateId >= templateCount) {\n            templateCount = templateId + 1;\n        }\n        emit TemplateAdded(templateId, template);\n    }\n    \n    function createYield(uint256 templateId, address vault, address vaultToken, bytes memory initData) external override returns (address accumulatedYield) {\n        address template = templates[templateId];\n        require(template != address(0), \"YieldFactory: template not found\");\n        \n        accumulatedYield = template.clone();\n        \n        bytes memory fullInitData = abi.encodeWithSignature(\n            \"initiate(address,address,bytes)\",\n            vault, \n            vaultToken,\n            initData\n        );\n        \n        (bool success, ) = accumulatedYield.call(fullInitData);\n        require(success, \"YieldFactory: initialization failed\");\n        \n        emit YieldCreated(templateId, accumulatedYield, msg.sender);\n        \n        return accumulatedYield;\n    }\n    \n    function getTemplate(uint256 templateId) external view override returns (address) {\n        return templates[templateId];\n    }\n    \n    function getTemplateCount() external view override returns (uint256) {\n        return templateCount;\n    }\n} "
    },
    "contracts/v2/interfaces/IAccumulatedYield.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/**\n * @title IAccumulatedYield\n * @dev Accumulated yield contract interface based on sushiswap's masterchef algorithm\n */\ninterface IAccumulatedYield {\n    // ============ Struct Definitions ============\n    \n    /**\n     * @dev Global pool information structure\n     */\n    struct GlobalPoolInfo {\n        uint256 totalAccumulatedShares;     // Total accumulated shares in the yield pool\n        uint256 lastDividendTime;          // Last dividend distribution time\n        uint256 totalDividend;             // Total dividend amount distributed\n        bool isActive;                     // Whether the yield pool is active\n        address shareToken;                // Address of the share token (user's share certificate)\n        address rewardToken;               // Address of the reward token (USDT and other stablecoins)\n    }\n    \n    /**\n     * @dev User information structure\n     */\n    struct UserInfo {\n        uint256 accumulatedShares;         // User's current accumulated shares\n        uint256 lastClaimTime;             // Last claim time\n        uint256 lastClaimDividend;         // Total dividend amount at last claim\n        uint256 totalClaimed;              // Total claimed amount\n    }\n    \n\n    \n    // ============ Event Definitions ============\n    \n    /**\n     * @dev Global pool initialization event\n     */\n    event GlobalPoolInitialized(\n        address indexed shareToken,\n        address indexed rewardToken,\n        uint256 timestamp\n    );\n    \n    /**\n     * @dev Dividend distribution event\n     */\n    event DividendDistributed(\n        uint256 amount,\n        uint256 timestamp,\n        address indexed validator,\n        bytes signature\n    );\n    \n    /**\n     * @dev Reward claim event\n     */\n    event RewardClaimed(\n        address indexed user,\n        uint256 claimedAmount,\n        uint256 transferredAmount,\n        uint256 timestamp\n    );\n    \n    /**\n     * @dev User pool update event\n     */\n    event UserPoolUpdated(\n        address indexed user,\n        uint256 newAccumulatedShares,\n        uint256 timestamp\n    );\n    \n    /**\n     * @dev Token transfer event (for tracking transfers that affect yield)\n     */\n    event ShareTokenTransferred(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 timestamp\n    );\n    \n    /**\n     * @dev Manager update event\n     */\n    event ManagerUpdated(\n        address indexed oldManager,\n        address indexed newManager\n    );\n    \n    /**\n     * @dev Dividend treasury update event\n     */\n    event DividendTreasuryUpdated(\n        address indexed oldTreasury,\n        address indexed newTreasury\n    );\n    \n\n    \n\n    \n    // ============ Global Pool Management Interface ============\n    \n    /**\n     * @dev Set manager\n     * @param _manager New manager address\n     */\n    function setManager(address _manager) external;\n    \n    /**\n     * @dev Set dividend treasury address\n     * @param _dividendTreasury New dividend treasury address\n     */\n    function setDividendTreasury(address _dividendTreasury) external;\n    \n\n    \n    /**\n     * @dev Update global pool status\n     * @param isActive Whether to activate\n     */\n    function updateGlobalPoolStatus(\n        bool isActive\n    ) external;\n    \n    // ============ User Operation Interface ============\n    \n    /**\n     * @dev User claim rewards\n     */\n    function claimReward() external;\n    \n    // ============ Yield Distribution Interface ============\n    \n    /**\n     * @dev Distribute dividend to global pool\n     * @param dividendAmount Distribution amount\n     * @param signature Dividend signature\n     */\n    function distributeDividend(\n        uint256 dividendAmount,\n        bytes memory signature\n    ) external;\n    \n    // ============ Token Transfer Related Interface ============\n    \n    /**\n     * @dev Update user pools on token transfer (core functionality)\n     * @param from Transfer from address\n     * @param to Transfer to address\n     * @param amount Transfer amount\n     * \n     * Note: This function should be called in the following cases:\n     * - User-to-user transfers\n     */\n    function updateUserPoolsOnTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n    \n    // ============ Query Interface ============\n    \n    /**\n     * @dev Query global pool information\n     * @return Global pool information structure\n     */\n    function getGlobalPoolInfo() external view returns (GlobalPoolInfo memory);\n    \n    /**\n     * @dev Query user information\n     * @param user User address\n     * @return User information structure\n     */\n    function getUserInfo(address user) external view returns (UserInfo memory);\n    \n    /**\n     * @dev Query user's pending rewards\n     * @param user User address\n     * @return Pending reward amount\n     */\n    function pendingReward(address user) external view returns (uint256);\n    \n\n    \n    /**\n     * @dev Query global pool total dividend amount\n     * @return Total dividend amount\n     */\n    function totalDividend() external view returns (uint256);\n    \n    /**\n     * @dev Query global pool total accumulated shares\n     * @return Total accumulated shares\n     */\n    function totalAccumulatedShares() external view returns (uint256);\n    \n    /**\n     * @dev Query current manager\n     * @return Manager address\n     */\n    function getManager() external view returns (address);\n    \n    /**\n     * @dev Query dividend treasury address\n     * @return Dividend treasury address\n     */\n    function getDividendTreasury() external view returns (address);\n    \n    /**\n     * @dev get demanded dividend nonce\n     * @return dividend nonce\n     */\n    function getDividendNonce() external view returns (uint256);\n    \n    /**\n     * @dev Calculate user's accumulated shares at specified balance\n     * @param user User address\n     * @param userBalance Specified user balance\n     * @return Accumulated shares\n     */\n    function calculateAccumulatedShares(address user, uint256 userBalance) external view returns (uint256);\n    \n    // ============  ============\n    function initiate(address _vault, address _shareToken, bytes memory _initData) external;\n} "
    },
    "contracts/v2/interfaces/ICreation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/**\n * @title ICreation\n * @dev  - \n */\ninterface ICreation {\n    // ============  ============\n    \n    /**\n     * @dev Vault\n     */\n    struct VaultInitData {\n        address validator;        // \n        bool whitelistEnabled;    // \n        address[] initialWhitelist; // \n    }\n    \n    /**\n     * @dev Token\n     */\n    struct TokenInitData {\n        string name;      // \n        string symbol;    // \n        uint8 decimals;   // \n    }\n    \n    /**\n     * @dev Fund\n     */\n    struct FundInitData {\n        uint256 startTime;           // UNIX\n        uint256 endTime;             // UNIX\n        address assetToken;          // USDT\n        uint256 maxSupply;           // \n        uint256 softCap;             // \n        uint256 sharePrice;          // \n        uint256 minDepositAmount;    // \n        uint256 manageFeeBps;        // 200 = 2%\n        address fundingReceiver;     // \n        address manageFeeReceiver;   // \n        uint256 decimalsMultiplier;  // 10^\n    }\n    \n    /**\n     * @dev Dividend\n     */\n    struct DividendInitData {\n        address rewardToken;   // USDT\n        address rewardManager; // \n    }\n    \n    /**\n     * @dev \n     */\n    struct DeploymentResult {\n        address vault;\n        address token;\n        address fund;\n        address accumulatedYield;\n    }\n    \n    /**\n     * @dev \n     */\n    struct Project {\n        string name;\n        address vault;\n        address token;\n        address fund;\n        address accumulatedYield;\n        uint256 createdAt;\n        address deployer;\n    }\n    \n    // ============  ============\n    \n    event VaultCreated(address indexed vault);\n    event TokenCreated(address indexed token);\n    event FundCreated(address indexed fund);\n    event YieldCreated(address indexed yield);\n    \n    \n    event ProjectCreated(\n        string name,\n        address vault,\n        address token,\n        address fund,\n        address yield,\n        address deployer\n        );\n    \n    event FactoriesUpdated(\n        address vaultFactory,\n        address tokenFactory,\n        address fundFactory,\n        address dividendFactory\n    );\n    \n    // ============  ============\n    \n    /**\n     * @dev \n     * @param _vaultFactory Vault\n     * @param _tokenFactory Token\n     * @param _fundFactory Fund\n     * @param _dividendFactory Dividend\n     */\n    function setFactories(\n        address _vaultFactory,\n        address _tokenFactory,\n        address _fundFactory,\n        address _dividendFactory\n    ) external;\n    \n    /**\n     * @dev \n     * @return vaultFactory Vault\n     * @return tokenFactory Token\n     * @return fundFactory Fund\n     * @return dividendFactory Dividend\n     */\n    function getFactories() external view returns (\n        address vaultFactory,\n        address tokenFactory,\n        address fundFactory,\n        address dividendFactory\n    );\n\n    // ============  ============\n    \n    function addToWhitelist(address user) external;\n    function removeFromWhitelist(address user) external;\n    \n    // ============  ============\n    \n    /**\n     * @dev bytes\n     * @param projectName \n     * @param vaultTemplateId VaultID\n     * @param vaultInitData Vaultbytes\n     * @param tokenTemplateId TokenID\n     * @param tokenInitData Tokenbytes\n     * @param fundTemplateId FundID\n     * @param fundInitData Fundbytes\n     * @param dividendTemplateId DividendID\n     * @param dividendInitData Dividendbytes\n     * @return result \n     */\n    function deployAll(\n        // \n        string memory projectName,\n        \n        // Vault\n        uint256 vaultTemplateId,\n        bytes memory vaultInitData,\n        \n        // Token\n        uint256 tokenTemplateId,\n        bytes memory tokenInitData,\n        \n        // Fund\n        uint256 fundTemplateId,\n        bytes memory fundInitData,\n        \n        // Dividend\n        uint256 dividendTemplateId,\n        bytes memory dividendInitData\n    ) external returns (DeploymentResult memory result);\n    \n\n    \n    /**\n     * @dev Vault\n     * @param templateId ID\n     * @param initData bytes\n     * @return vault Vault\n     */\n    function deployVault(\n        uint256 templateId,\n        bytes memory initData\n    ) external returns (address vault);\n    \n    /**\n     * @dev Token\n     * @param templateId ID\n     * @param vault Vault\n     * @param initData bytes\n     * @return token Token\n     */\n    function deployToken(\n        uint256 templateId,\n        address vault,\n        bytes memory initData\n    ) external returns (address token);\n    \n    /**\n     * @dev Fund\n     * @param templateId ID\n     * @param vault Vault\n     * @param initData bytes\n     * @return fund Fund\n     */\n    function deployFund(\n        uint256 templateId,\n        address vault,\n        bytes memory initData\n    ) external returns (address fund);\n    \n    /**\n     * @dev Dividend\n     * @param templateId ID\n     * @param vault Vault\n     * @param token Token\n     * @param initData bytes\n     * @return dividend Dividend\n     */\n    function deployDividend(\n        uint256 templateId,\n        address vault,\n        address token,\n        bytes memory initData\n    ) external returns (address dividend);\n    \n    // ============  ============\n    \n    /**\n     * @dev \n     * @param user \n     * @return projects \n     */\n    function getUserProjects(address user) external view returns (DeploymentResult[] memory projects);\n    \n    /**\n     * @dev \n     * @param projectName \n     * @return project \n     */\n    function getProjectByName(string memory projectName) external view returns (Project memory);\n    \n    /**\n     * @dev \n     * @param user \n     * @return projects \n     */\n    function getUserProjectDetails(address user) external view returns (Project[] memory);\n} "
    },
    "contracts/v2/interfaces/ICrowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/**\n * @title ICrowdsale\n * @dev Crowdsale module interface\n */\ninterface ICrowdsale {\n    // ============ Struct Definitions ============\n    \n    /**\n     * @dev On-chain signature data structure\n     */\n    struct OnChainSignatureData {\n        string operation;        // Operation name (\"deposit\", \"redeem\")\n        uint256 amount;          // Deposit amount\n        address receiver;        // Receiver address\n        uint256 nonce;          // Nonce to prevent replay attacks\n        uint256 chainId;        // Chain ID to prevent cross-chain replay\n        address contractAddress; // Contract address to prevent replay\n    }\n    \n    /**\n     * @dev Off-chain signature data structure\n     */\n    struct OffChainSignatureData {\n        uint256 amount;          // amount\n        address receiver;        // Receiver address\n    }\n    \n    // ============ Events ============\n    event Deposit(address indexed receiver, uint256 assertAmount, uint256 manageFee, uint256 shares);\n    event FundFailRedeem(address redeemer,uint256 shares,uint256 assetAmount,uint256 feeAmount);\n    event OffChainDeposit(address indexed receiver, uint256 assertAmount, uint256 shares, bytes signature);\n    event OffChainRedeem(address indexed receiver, uint256 assertAmount);\n    event FundingAssetsWithdrawn(address indexed receiver, uint256 amount);\n    event ManageFeeWithdrawn(address indexed receiver, uint256 amount);\n    event TokenUnpausedOnFundingSuccess();\n\n    // ============ Basic Field Query Interface ============\n    function vault() external view returns (address);\n    function startTime() external view returns (uint256);\n    function endTime() external view returns (uint256);\n    function assetToken() external view returns (address);\n    function maxSupply() external view returns (uint256);\n    function softCap() external view returns (uint256);\n    function sharePrice() external view returns (uint256);\n    function minDepositAmount() external view returns (uint256);\n    function manageFeeBps() external view returns (uint256);\n    function fundingReceiver() external view returns (address);\n    function manageFeeReceiver() external view returns (address);\n    function decimalsMultiplier() external view returns (uint256);\n    function manager() external view returns (address);\n    function fundingAssets() external view returns (uint256);\n    function manageFee() external view returns (uint256);\n\n    // ============ Funding Operations Interface ============\n    // User initiated, requires manager signature\n    function deposit(uint256 amount, address receiver, bytes memory signature) external returns (uint256);\n    \n    // User initiated, requires manager signature - redeems all user shares\n    function redeem(address receiver, bytes memory signature) external;\n    \n    // Backend manager initiated, requires DRDS signature verification\n    function offChainDeposit(uint256 amount, address receiver, bytes memory drdsSignature) external;\n    \n    // Backend manager initiated - redeems all user shares\n    function offChainRedeem(address receiver) external;\n\n    // ============ Fund Management Interface ============\n    function withdrawFundingAssets() external;\n    function withdrawManageFee() external;\n    function unpauseTokenOnFundingSuccess() external;\n\n    // ============ Status Query Interface ============\n    function isFundingSuccessful() external view returns (bool);\n    function isFundingPeriodActive() external view returns (bool);\n    function getTotalRaised() external view returns (uint256);\n    function getRemainingSupply() external view returns (uint256);\n    \n    // ============ Signature Query Interface ============\n    function getManagerNonce() external view returns (uint256);\n    function getDepositSignatureMessage(uint256 amount, address receiver, uint256 nonce) external view returns (bytes32);\n    function getRedeemSignatureMessage(uint256 amount, address receiver, uint256 nonce) external view returns (bytes32);\n    \n    // ============  ============\n    function initiate(address _vault, bytes memory _initData) external;\n} "
    },
    "contracts/v2/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/**\n * @title IVaultFactory\n * @dev Vault\n */\ninterface IVaultFactory {\n    event TemplateAdded(uint256 indexed templateId, address indexed template);\n    event VaultCreated(uint256 indexed templateId, address indexed vault, address indexed deployer);\n    \n    function createVault(uint256 templateId, bytes memory initData) external returns (address);\n    function addTemplate(uint256 templateId, address template) external;\n    function getTemplate(uint256 templateId) external view returns (address);\n    function getTemplateCount() external view returns (uint256);\n}\n\n/**\n * @title ITokenFactory\n * @dev Token\n */\ninterface ITokenFactory {\n    event TemplateAdded(uint256 indexed templateId, address indexed template);\n    event TokenCreated(uint256 indexed templateId, address indexed token, address indexed vault);\n    \n    function createToken(uint256 templateId, address vault, bytes memory initData) external returns (address);\n    function addTemplate(uint256 templateId, address template) external;\n    function getTemplate(uint256 templateId) external view returns (address);\n    function getTemplateCount() external view returns (uint256);\n}\n\n/**\n * @title IFundFactory\n * @dev Fund\n */\ninterface IFundFactory {\n    event TemplateAdded(uint256 indexed templateId, address indexed template);\n    event FundCreated(uint256 indexed templateId, address indexed fund, address indexed vault);\n    \n    function createFund(uint256 templateId, address vault, bytes memory initData) external returns (address);\n    function addTemplate(uint256 templateId, address template) external;\n    function getTemplate(uint256 templateId) external view returns (address);\n    function getTemplateCount() external view returns (uint256);\n}\n\n/**\n * @title IYieldFactory\n * @dev Yield\n */\ninterface IYieldFactory {\n    event TemplateAdded(uint256 indexed templateId, address indexed template);\n    event YieldCreated(uint256 indexed templateId, address indexed accumulatedYield, address indexed vault);\n    \n    function createYield(uint256 templateId, address vault, address token, bytes memory initData) external returns (address);\n    function addTemplate(uint256 templateId, address template) external;\n    function getTemplate(uint256 templateId) external view returns (address);\n    function getTemplateCount() external view returns (uint256);\n} "
    },
    "contracts/v2/interfaces/IToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IToken\n * @dev TokenERC20\n */\ninterface IToken is IERC20 {\n    // ============  ============\n    event TokenMinted(address indexed to, uint256 amount);\n    event TokenBurned(address indexed from, uint256 amount);\n    event TokenPaused();\n    event TokenUnpaused();\n\n    // ============  ============\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function paused() external view returns (bool);\n    function vault() external view returns (address);\n\n    // ============  ============\n    function mint(address to, uint256 amount) external;\n    function burnFrom(address account, uint256 amount) external;\n\n    // ============  ============\n    function pause() external;\n    function unpause() external;\n    \n    // ============  ============\n    function initiate(address _vault, bytes memory _initData) external;\n} "
    },
    "contracts/v2/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/**\n * @title IVault\n * @dev Vault\n */\ninterface IVault {\n    // ============  ============\n    event WhitelistAdded(address indexed addr);\n    event WhitelistRemoved(address indexed addr);\n    event WhitelistStatusChanged(bool enabled);\n    event TokenPaused();\n    event TokenUnpaused();\n    event VerifyDataUpdated(bytes dataHash, bytes signature);\n\n    // ============  ============\n    function vaultToken() external view returns (address);\n    function manager() external view returns (address);\n    function whitelistEnabled() external view returns (bool);\n    function isWhitelisted(address addr) external view returns (bool);\n    function validator() external view returns (address);\n    function dataHash() external view returns (bytes memory);\n    function signature() external view returns (bytes memory);\n\n    // ============  ============\n    function addToWhitelist(address _addr) external;\n    function removeFromWhitelist(address _addr) external;\n    function enableWhitelist() external;\n    function disableWhitelist() external;\n    function isWhiteList() external view returns (bool);\n\n    // ============  ============\n    function verify() external pure returns (bool);\n    function updateVerifyData(bytes memory hash, bytes memory _signature) external;\n\n    // ============  ============\n    function pauseToken() external;\n    function unpauseToken() external;\n    function isTokenPaused() external view returns (bool);\n    \n    // ============  ============\n    function mintToken(address to, uint256 amount) external;\n    function burnToken(address from, uint256 amount) external;\n    \n    // ============ transfer hook ============\n    function onTokenTransfer(address from, address to, uint256 amount) external;\n    \n    // ============  ============\n    function configureModules(address _vaultToken, address _funding, address _yield) external;\n    function setVaultToken(address _vaultToken) external;\n    function setFundingModule(address _funding) external;\n    function setDividendModule(address _dividendModule) external;\n    \n    // ============  ============\n    function isFundingSuccessful() external view returns (bool);\n    \n    // ============  ============\n    function initiate(bytes memory _initData) external;\n} "
    },
    "contracts/v2/mocks/MockUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockUSDT is ERC20 {\n    event Mint(address indexed account, uint256 amount);\n    event Burn(address indexed account, uint256 amount);\n\n    constructor(\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) {}\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n        emit Mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external {\n        _spendAllowance(from, msg.sender, amount);\n        _burn(from, amount);\n        emit Burn(from, amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n}\n"
    },
    "contracts/v2/templates/funding/Crowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../../interfaces/ICrowdsale.sol\";\nimport \"../../interfaces/IVault.sol\";\nimport \"../../interfaces/IToken.sol\";\n\n/**\n * @title Crowdsale\n * @dev Crowdsale template implementation, providing fair fundraising functionality\n * @notice Supports on-chain and off-chain deposits, refundable if funding fails\n */\ncontract Crowdsale is ICrowdsale, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using ECDSA for bytes32;\n    \n    // ============ State Variables ============\n    \n    address public override vault;\n    uint256 public override startTime;\n    uint256 public override endTime;\n    address public override assetToken;\n    uint256 public override maxSupply;\n    uint256 public override softCap;\n    uint256 public override sharePrice;\n    uint256 public override minDepositAmount;\n    uint256 public override manageFeeBps;\n    address public override fundingReceiver;\n    address public override manageFeeReceiver;\n    uint256 public override decimalsMultiplier;\n    address public override manager;\n    uint256 public override fundingAssets;\n    uint256 public override manageFee;\n    \n    // Constants\n    uint256 public constant BPS_DENOMINATOR = 10_000;\n    uint256 public constant SHARE_PRICE_DENOMINATOR = 10**8;\n    \n    // Signature verification\n    uint256 public managerNonce;\n    \n    // Initialization state\n    bool private _initialized;\n    \n    // ============ Modifiers ============\n    \n    modifier onlyManager() {\n        require(msg.sender == manager, \"Crowdsale: only manager\");\n        _;\n    }\n    \n    modifier onlyDuringFunding() {\n        require(!isFundingSuccessful(), \"Crowdsale: funding was successful\");\n        require(isFundingPeriodActive(), \"Crowdsale: not in funding period\");\n        _;\n    }\n    \n\n    modifier onlyAfterFundingFailed() {\n        require(!isFundingSuccessful(), \"Crowdsale: funding was successful\");\n        require(block.timestamp > endTime, \"Crowdsale: funding period not ended\");\n        _;\n    }\n\n    modifier onlyAfterFundingSuccess() {\n        require(isFundingSuccessful(), \"Crowdsale: funding was not successful\");\n        _;\n    }\n    \n    modifier whenInitialized() {\n        require(_initialized, \"Crowdsale: not initialized\");\n        _;\n    }\n    \n    modifier whenNotInitialized() {\n        require(!_initialized, \"Crowdsale: already initialized\");\n        _;\n    }\n    \n    // ============ Constructor ============\n    \n    constructor() {\n    }\n    \n    // ============ Initialization Function ============\n\n    /**\n     * @dev Unified initialization interface\n     * @param _vault Vault address\n     * @param _initData Encoded initialization data\n     */\n    function initiate(address _vault, bytes memory _initData) external override whenNotInitialized {\n        require(_vault != address(0), \"Crowdsale: invalid vault\");\n        \n        (uint256 _startTime, uint256 _endTime, address _assetToken, uint256 _maxSupply, uint256 _softCap, \n         uint256 _sharePrice, uint256 _minDepositAmount, uint256 _manageFeeBps, address _fundingReceiver, \n         address _manageFeeReceiver, uint256 _decimalsMultiplier, address _manager) = \n            abi.decode(_initData, (uint256, uint256, address, uint256, uint256, uint256, uint256, uint256, address, address, uint256, address));\n        \n        _initCrowdsale(\n            _vault, _startTime, _endTime, _assetToken, _maxSupply, _softCap, \n            _sharePrice, _minDepositAmount, _manageFeeBps, _fundingReceiver, \n            _manageFeeReceiver, _decimalsMultiplier, _manager\n        );\n    }\n    \n    // ============ Funding Operations ============\n    \n    /**\n     * @dev Deposit to purchase shares (user initiated, requires manager signature)\n     * @param amount Deposit amount\n     * @param receiver Receiver address\n     * @param signature Manager signature\n     * @return shares Number of shares received\n     */\n    function deposit(uint256 amount, address receiver, bytes memory signature) \n        external \n        override \n        onlyDuringFunding \n        whenInitialized\n        nonReentrant \n        returns (uint256 shares) \n    {\n        require(amount >= minDepositAmount, \"Crowdsale: amount less than minimum\");\n        require(receiver != address(0), \"Crowdsale: invalid receiver\");\n        \n        // Verify signature using OnChainSignatureData structure\n        uint256 nonce = managerNonce++;\n        \n        ICrowdsale.OnChainSignatureData memory sigData = ICrowdsale.OnChainSignatureData({\n            operation: \"deposit\",\n            amount: amount,\n            receiver: receiver,\n            nonce: nonce,\n            chainId: block.chainid,\n            contractAddress: address(this)\n        });\n        \n        bytes32 messageHash = keccak256(abi.encodePacked(\n            sigData.operation,\n            sigData.amount,\n            sigData.receiver,\n            sigData.nonce,\n            sigData.chainId,\n            sigData.contractAddress\n        ));\n        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();\n        address signer = ethSignedMessageHash.recover(signature);\n        require(signer == manager, \"Crowdsale: invalid signature\");\n        \n        // Calculate shares for the requested amount (with fee deduction for on-chain)\n        uint256 feeAmount = (amount * manageFeeBps) / BPS_DENOMINATOR;\n        uint256 netAmount = amount - feeAmount;\n        uint256 requestedShares = _getSharesForAssets(netAmount);\n        \n        uint256 currentSupply = IToken(IVault(vault).vaultToken()).totalSupply();\n        uint256 remainingSupply = maxSupply - currentSupply;\n        \n        // Check if we can fulfill the full request\n        uint256 actualAmount;\n        uint256 actualShares;\n        if (requestedShares > remainingSupply) {\n            // Calculate actual amount that can be deposited\n            actualShares = remainingSupply;\n            uint256 actualNetAmount = _getAssetsForShares(remainingSupply);\n            actualAmount = (actualNetAmount * BPS_DENOMINATOR) / (BPS_DENOMINATOR - manageFeeBps); // Convert back to gross amount\n            require(actualAmount >= minDepositAmount, \"Crowdsale: remaining amount below minimum\");\n        } else {\n            actualShares = requestedShares;\n            actualAmount = amount;\n        }\n        \n        // Calculate management fee based on actual amount\n        uint256 manageFeeAmount = (actualAmount * manageFeeBps) / BPS_DENOMINATOR;\n        \n        // Update state\n        manageFee += manageFeeAmount;\n        uint256 netAmountForFunding = actualAmount - manageFeeAmount;\n        fundingAssets += netAmountForFunding; // Only net amount goes to funding\n        \n        // Transfer assets (user pays the full actual amount, fee is deducted)\n        IERC20(assetToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            actualAmount\n        );\n        \n        // Mint tokens through vault\n        IVault(vault).mintToken(receiver, actualShares);\n        \n        emit Deposit(receiver, actualAmount, manageFeeAmount, actualShares);\n        return actualShares;\n    }\n    \n    /**\n     * @dev Redeem all shares (user initiated, requires manager signature)\n     * @param receiver Receiver address\n     * @param signature Manager signature\n     */\n    function redeem(address receiver, bytes memory signature) \n        external \n        override \n        onlyAfterFundingFailed \n        whenInitialized\n        nonReentrant \n    {\n        require(!isFundingSuccessful(), \"Crowdsale: funding was successful\");\n        require(receiver != address(0), \"Crowdsale: invalid receiver\");\n        \n        // Get user's total balance (redeem all shares)\n        uint256 userShares = IToken(IVault(vault).vaultToken()).balanceOf(msg.sender);\n        require(userShares > 0, \"Crowdsale: no shares to redeem\");\n        \n        // Verify signature using OnChainSignatureData structure\n        uint256 nonce = managerNonce++;\n        \n        ICrowdsale.OnChainSignatureData memory sigData = ICrowdsale.OnChainSignatureData({\n            operation: \"redeem\",\n            amount: userShares,\n            receiver: receiver,\n            nonce: nonce,\n            chainId: block.chainid,\n            contractAddress: address(this)\n        });\n        \n        bytes32 messageHash = keccak256(abi.encodePacked(\n            sigData.operation,\n            sigData.amount,\n            sigData.receiver,\n            sigData.nonce,\n            sigData.chainId,\n            sigData.contractAddress\n        ));\n        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();\n        address signer = ethSignedMessageHash.recover(signature);\n        require(signer == manager, \"Crowdsale: invalid signature\");\n        \n        // Calculate refund assets for all shares\n        uint256 assetAmount = _getAssetsForShares(userShares);\n        uint256 feeAmount = (assetAmount * manageFeeBps) / BPS_DENOMINATOR;\n        \n        // Burn all tokens through vault\n        IVault(vault).burnToken(msg.sender, userShares);\n        \n        // Update state\n        fundingAssets -= assetAmount;\n        manageFee -= feeAmount;\n        \n        // Refund assets (including management fee)\n        IERC20(assetToken).safeTransfer(receiver, assetAmount + feeAmount);\n        \n        emit FundFailRedeem(receiver, userShares, assetAmount, feeAmount);\n    }\n    \n    /**\n     * @dev Off-chain deposit (only manager can call, requires DRDS signature verification)\n     * @param amount Deposit amount\n     * @param receiver Receiver address\n     * @param drdsSignature DRDS signature data\n     */\n    function offChainDeposit(uint256 amount, address receiver, bytes memory drdsSignature) \n        external \n        override \n        onlyManager \n        onlyDuringFunding \n        whenInitialized\n    {\n        require(amount >= minDepositAmount, \"Crowdsale: amount less than minimum\");\n        require(receiver != address(0), \"Crowdsale: invalid receiver\");\n        \n        // Verify DRDS signature using OffChainSignatureData structure\n        ICrowdsale.OffChainSignatureData memory sigData = ICrowdsale.OffChainSignatureData({\n            amount: amount,\n            receiver: receiver\n        });\n\n        // Get validator address from Vault\n        address validator = IVault(vault).validator();\n        require(validator != address(0), \"Crowdsale: validator not set\");\n        \n        bytes32 messageHash = keccak256(abi.encodePacked(\n            \"offChainDeposit\",\n            sigData.amount,\n            sigData.receiver,\n            block.chainid,\n            address(this)\n        ));\n        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();\n        address signer = ethSignedMessageHash.recover(drdsSignature);\n        require(signer == validator, \"Crowdsale: invalid drds signature\");\n        \n        // Calculate shares for the requested amount (no fee deduction for off-chain)\n        uint256 requestedShares = _getSharesForAssets(amount);\n        \n        uint256 currentSupply = IToken(IVault(vault).vaultToken()).totalSupply();\n        uint256 remainingSupply = maxSupply - currentSupply;\n        \n        // Check if we can fulfill the full request\n        uint256 actualAmount;\n        uint256 actualShares;\n        if (requestedShares > remainingSupply) {\n            // Calculate actual amount that can be deposited\n            actualShares = remainingSupply;\n            actualAmount = _getAssetsForShares(remainingSupply);\n            require(actualAmount >= minDepositAmount, \"Crowdsale: remaining amount below minimum\");\n        } else {\n            actualShares = requestedShares;\n            actualAmount = amount;\n        }\n        \n        // No management fee for off-chain deposits\n        \n        // Mint tokens through vault\n        IVault(vault).mintToken(receiver, actualShares);\n        \n        emit OffChainDeposit(receiver, actualAmount, actualShares, drdsSignature);\n    }\n    \n    /**\n     * @dev Off-chain redeem all shares (only manager can call)\n     * @param receiver Receiver address\n     */\n    function offChainRedeem(address receiver) \n        external \n        override \n        onlyManager \n        onlyAfterFundingFailed \n        whenInitialized\n    {\n        require(!isFundingSuccessful(), \"Crowdsale: funding was successful\");\n        require(receiver != address(0), \"Crowdsale: invalid receiver\");\n        \n        // Get user's total balance (redeem all shares)\n        uint256 userShares = IToken(IVault(vault).vaultToken()).balanceOf(receiver);\n        require(userShares > 0, \"Crowdsale: no shares to redeem\");\n        \n        // Calculate refund assets for all shares\n        uint256 assetAmount = _getAssetsForShares(userShares);\n        \n        // Burn all tokens through vault\n        IVault(vault).burnToken(receiver, userShares);\n                \n        emit OffChainRedeem(receiver, assetAmount);\n    }\n    \n    // ============ Fund Management ============\n    \n    /**\n     * @dev Withdraw funding assets (only when funding is successful)\n     */\n    function withdrawFundingAssets() external override onlyAfterFundingSuccess whenInitialized nonReentrant {\n        require(msg.sender == fundingReceiver, \"Crowdsale: only funding receiver\");\n        require(fundingAssets > 0, \"Crowdsale: no funding assets\");\n        \n        uint256 amount = fundingAssets;\n        fundingAssets = 0;\n        \n        IERC20(assetToken).safeTransfer(fundingReceiver, amount);\n        \n        emit FundingAssetsWithdrawn(fundingReceiver, amount);\n    }\n    \n    /**\n     * @dev Withdraw management fee (only when funding is successful)\n     */\n    function withdrawManageFee() external override onlyAfterFundingSuccess whenInitialized nonReentrant {\n        require(msg.sender == manageFeeReceiver, \"Crowdsale: only manage fee receiver\");\n        require(manageFee > 0, \"Crowdsale: no manage fee\");\n        \n        uint256 amount = manageFee;\n        manageFee = 0;\n        \n        IERC20(assetToken).safeTransfer(manageFeeReceiver, amount);\n        \n        emit ManageFeeWithdrawn(manageFeeReceiver, amount);\n    }\n    \n    /**\n     * @dev Unpause token trading when funding is successful\n     * This function should be called after funding period ends and funding is successful\n     */\n    function unpauseTokenOnFundingSuccess() external onlyManager onlyAfterFundingSuccess whenInitialized {\n        // Unpause token trading through vault\n        IVault(vault).unpauseToken();\n        \n        emit TokenUnpausedOnFundingSuccess();\n    }\n    \n    // ============ Status Queries ============\n    \n    /**\n     * @dev Check if funding is successful\n     * @return Whether funding is successful\n     */\n    function isFundingSuccessful() public view override returns (bool) {\n        return IToken(IVault(vault).vaultToken()).totalSupply() >= softCap;\n    }\n    \n    /**\n     * @dev Check if funding period is active\n     * @return Whether funding period is active\n     */\n    function isFundingPeriodActive() public view override returns (bool) {\n        return block.timestamp >= startTime && block.timestamp <= endTime;\n    }\n    \n    /**\n     * @dev Get total amount raised\n     * @return Total amount raised\n     */\n    function getTotalRaised() external view override returns (uint256) {\n        return fundingAssets;\n    }\n    \n    /**\n     * @dev Get remaining supply\n     * @return Remaining supply\n     */\n    function getRemainingSupply() external view override returns (uint256) {\n        uint256 currentSupply = IToken(IVault(vault).vaultToken()).totalSupply();\n        return maxSupply > currentSupply ? maxSupply - currentSupply : 0;\n    }\n    \n    // ============ Internal Functions ============\n\n    /**\n     * @dev _Initialize crowdsale contract (for Clones pattern)\n     * @param _vault Vault contract address\n     * @param _startTime Start time\n     * @param _endTime End time\n     * @param _assetToken Asset token address\n     * @param _maxSupply Maximum supply\n     * @param _softCap Soft cap (funding threshold)\n     * @param _sharePrice Share price\n     * @param _minDepositAmount Minimum deposit amount\n     * @param _manageFeeBps Management fee basis points\n     * @param _fundingReceiver Funding receiver address\n     * @param _manageFeeReceiver Management fee receiver address\n     * @param _decimalsMultiplier Decimals multiplier\n     * @param _manager Manager address\n     */\n    function _initCrowdsale(\n        address _vault,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _assetToken,\n        uint256 _maxSupply,\n        uint256 _softCap,\n        uint256 _sharePrice,\n        uint256 _minDepositAmount,\n        uint256 _manageFeeBps,\n        address _fundingReceiver,\n        address _manageFeeReceiver,\n        uint256 _decimalsMultiplier,\n        address _manager\n    ) internal whenNotInitialized {\n        require(_vault != address(0), \"Crowdsale: invalid vault\");\n        require(_startTime < _endTime, \"Crowdsale: invalid time range\");\n        require(_endTime > block.timestamp, \"Crowdsale: end time in past\");\n        require(_assetToken != address(0), \"Crowdsale: invalid asset token\");\n        require(_maxSupply > 0, \"Crowdsale: invalid max supply\");\n        require(_softCap > 0 && _softCap <= _maxSupply, \"Crowdsale: invalid soft cap\");\n        require(_sharePrice > 0, \"Crowdsale: invalid share price\");\n        require(_minDepositAmount > 0, \"Crowdsale: invalid min deposit\");\n        require(_manageFeeBps <= BPS_DENOMINATOR, \"Crowdsale: invalid manage fee\");\n        require(_fundingReceiver != address(0), \"Crowdsale: invalid funding receiver\");\n        require(_manageFeeReceiver != address(0), \"Crowdsale: invalid fee receiver\");\n        require(_manager != address(0), \"Crowdsale: invalid manager\");\n        \n        vault = _vault;\n        startTime = _startTime;\n        endTime = _endTime;\n        assetToken = _assetToken;\n        maxSupply = _maxSupply;\n        softCap = _softCap;\n        sharePrice = _sharePrice;\n        minDepositAmount = _minDepositAmount;\n        manageFeeBps = _manageFeeBps;\n        fundingReceiver = _fundingReceiver;\n        manageFeeReceiver = _manageFeeReceiver;\n        decimalsMultiplier = _decimalsMultiplier;\n        manager = _manager;\n        \n        _initialized = true;\n        _transferOwnership(_manager);\n    }\n    \n    /**\n     * @dev Scale up amount by decimalsMultiplier\n     * @param amount Amount to scale up\n     * @return Scaled up amount\n     */\n    function _scaleUp(uint256 amount) internal view returns (uint256) {\n        return amount * decimalsMultiplier;\n    }\n\n    /**\n     * @dev Scale down amount by decimalsMultiplier\n     * @param amount Amount to scale down\n     * @return Scaled down amount\n     */\n    function _scaleDown(uint256 amount) internal view returns (uint256) {\n        return amount / decimalsMultiplier;\n    }\n\n    /**\n     * @dev Calculate shares for given asset amount\n     * @param assetAmount Asset amount\n     * @return Number of shares\n     */\n    function _getSharesForAssets(uint256 assetAmount) internal view returns (uint256) {\n        uint256 scaledAmount = _scaleUp(assetAmount);\n        return (scaledAmount * SHARE_PRICE_DENOMINATOR) / sharePrice;\n    }\n    \n    /**\n     * @dev Calculate assets for given share amount\n     * @param shareAmount Share amount\n     * @return Asset amount\n     */\n    function _getAssetsForShares(uint256 shareAmount) internal view returns (uint256) {\n        // 1. scaledAmount = shareAmount * sharePrice / SHARE_PRICE_DENOMINATOR\n        // 2. then scaleDown\n        uint256 scaledAmount = (shareAmount * sharePrice) / SHARE_PRICE_DENOMINATOR;\n        return _scaleDown(scaledAmount);\n    }\n    \n    // ============ Query Interface ============\n    \n    /**\n     * @dev Query if initialized\n     */\n    function isInitialized() external view returns (bool) {\n        return _initialized;\n    }\n    \n    /**\n     * @dev Query manager nonce for signature verification\n     * @return Current manager nonce\n     */\n    function getManagerNonce() external view returns (uint256) {\n        return managerNonce;\n    }\n    \n    /**\n     * @dev Generate deposit signature message hash for backend signing\n     * @param amount Deposit amount\n     * @param receiver Receiver address\n     * @param nonce Manager nonce\n     * @return Message hash to be signed\n     */\n    function getDepositSignatureMessage(\n        uint256 amount,\n        address receiver,\n        uint256 nonce\n    ) external view returns (bytes32) {\n        bytes32 messageHash = keccak256(abi.encodePacked(\n            \"deposit\",\n            amount,\n            receiver,\n            nonce,\n            block.chainid,\n            address(this)\n        ));\n        return messageHash;\n    }\n    \n    /**\n     * @dev Generate redeem signature message hash for backend signing\n     * @param amount Number of shares to redeem\n     * @param receiver Receiver address\n     * @param nonce Manager nonce\n     * @return Message hash to be signed\n     */\n    function getRedeemSignatureMessage(\n        uint256 amount,\n        address receiver,\n        uint256 nonce\n    ) external view returns (bytes32) {\n        bytes32 messageHash = keccak256(abi.encodePacked(\n            \"redeem\",\n            amount,\n            receiver,\n            nonce,\n            block.chainid,\n            address(this)\n        ));\n        return messageHash;\n    }\n} "
    },
    "contracts/v2/templates/token/VaultToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/IToken.sol\";\nimport \"../../interfaces/IVault.sol\";\n\n/**\n * @title VaultToken\n * @dev Vault share certificate token, supporting accumulated yield distribution\n * @notice Inherits ERC20 standard, supports pause functionality, integrates with AccumulatedYield\n */\ncontract VaultToken is ERC20, Pausable, IToken, Ownable {\n    // ============ State Variables ============\n    address public vault;\n    \n    // Token metadata\n    string private _tokenName;\n    string private _tokenSymbol;\n    uint8 private _tokenDecimals;\n    \n    // Initialization state\n    bool private _initialized;\n    \n    // Constants\n    uint8 private constant MAX_DECIMALS = 24;\n    \n    // ============ Modifiers ============\n    \n    modifier onlyVault() {\n        require(msg.sender == vault, \"VaultToken: only vault\");\n        _;\n    }\n\n    modifier whenWhitelisted(address user) {\n        // Skip whitelist check for mint (from = address(0)) and burn (to = address(0)) operations\n        if (user != address(0)) {\n            IVault vaultContract = IVault(vault);\n            if (vaultContract.whitelistEnabled()) {\n                require(vaultContract.isWhitelisted(user), \"VaultToken: not whitelisted\");\n            }\n        }\n        _;\n    }\n    \n    modifier whenInitialized() {\n        require(_initialized, \"VaultToken: not initialized\");\n        _;\n    }\n    \n    modifier whenNotInitialized() {\n        require(!_initialized, \"VaultToken: already initialized\");\n        _;\n    }\n    \n    // ============ Constructor ============\n    \n    constructor() ERC20(\"\", \"\") {\n        // Empty constructor, supports Clones pattern\n        //  Clones owner  initToken \n    }\n    \n    // ============ Initialization Function ============\n    /**\n     * @dev Unified initialization interface\n     * @param _vault Vault address\n     * @param _initData Encoded initialization data\n     */\n    function initiate(address _vault, bytes memory _initData) external override whenNotInitialized {\n        require(_vault != address(0), \"VaultToken: invalid vault\");\n        \n        (string memory _name, string memory _symbol, uint8 _decimals) = \n            abi.decode(_initData, (string, string, uint8));\n        \n        _initToken(_vault, _name, _symbol, _decimals);\n    }\n    \n    // ============ IToken Interface Implementation ============\n    \n    /**\n     * @dev Query token name\n     */\n    function name() public view virtual override(ERC20, IToken) returns (string memory) {\n        return _tokenName;\n    }\n    \n    /**\n     * @dev Query token symbol\n     */\n    function symbol() public view virtual override(ERC20, IToken) returns (string memory) {\n        return _tokenSymbol;\n    }\n    \n    /**\n     * @dev Query token decimals\n     */\n    function decimals() public view virtual override(ERC20, IToken) returns (uint8) {\n        return _tokenDecimals;\n    }\n    \n    /**\n     * @dev Query pause status\n     */\n    function paused() public view virtual override(Pausable, IToken) returns (bool) {\n        return Pausable.paused();\n    }\n    \n\n    \n    // ============ Minting and Burning Interface ============\n    \n    /**\n     * @dev Mint function\n     * @param to Recipient address\n     * @param amount Mint amount\n     */\n    function mint(address to, uint256 amount) external override onlyVault whenInitialized {\n        require(to != address(0), \"VaultToken: mint to zero address\");\n        require(amount > 0, \"VaultToken: mint amount must be positive\");\n        \n        _mint(to, amount);\n        \n        emit TokenMinted(to, amount);\n    }\n    \n    /**\n     * @dev Burn function\n     * @param account Address to burn from\n     * @param amount Burn amount\n     */\n    function burnFrom(address account, uint256 amount) external override onlyVault whenInitialized {\n        require(account != address(0), \"VaultToken: burn from zero address\");\n        require(amount > 0, \"VaultToken: burn amount must be positive\");\n        require(balanceOf(account) >= amount, \"VaultToken: insufficient balance\");\n        \n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n        \n        emit TokenBurned(account, amount);\n    }\n\n    // ============ Transfer Interface ============\n\n    /**\n     * @dev transfer function, check whitelist for sender and recipient\n     * @param to Recipient address\n     * @param amount Transfer amount\n     */\n    function transfer(address to, uint256 amount) public virtual override(ERC20, IERC20) whenWhitelisted(_msgSender()) whenWhitelisted(to) returns (bool) {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @dev transferFrom function, check whitelist for sender and recipient\n     * @param from Sender address\n     * @param to Recipient address\n     * @param amount Transfer amount\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override(ERC20, IERC20) whenWhitelisted(from) whenWhitelisted(to) returns (bool) {\n        return super.transferFrom(from, to, amount);\n    }\n\n    // ============ Pause Control Interface ============\n    \n    /**\n     * @dev Pause token transfers\n     */\n    function pause() external override onlyVault whenInitialized {\n        if (!paused()) {\n            _pause();\n            emit TokenPaused();\n        }\n    }\n    \n    /**\n     * @dev Resume token transfers\n     */\n    function unpause() external override onlyVault whenInitialized whenPaused {\n        _unpause();\n        \n        emit TokenUnpaused();\n    }\n    \n\n    \n    // ============ Internal Functions ============\n\n    /**\n     * @dev Check whitelist status for a user\n     * @param user User address to check\n     */\n    function _checkWhitelist(address user) internal view {\n        IVault vaultContract = IVault(vault);\n        if (vaultContract.whitelistEnabled()) {\n            require(vaultContract.isWhitelisted(user), \"VaultToken: not whitelisted\");\n        }\n    }\n        \n    /**\n     * @dev Initialize token (for Clones pattern)\n     * @param _vault Vault contract address\n     * @param _name Token name\n     * @param _symbol Token symbol\n     * @param _decimals Token decimals\n     */\n    function _initToken(\n        address _vault,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) internal whenNotInitialized {\n        require(_vault != address(0), \"VaultToken: invalid vault address\");\n        require(bytes(_name).length > 0, \"VaultToken: empty name\");\n        require(bytes(_symbol).length > 0, \"VaultToken: empty symbol\");\n        require(_decimals <= MAX_DECIMALS, \"VaultToken: invalid decimals\");\n        \n        vault = _vault;\n        _tokenName = _name;\n        _tokenSymbol = _symbol;\n        _tokenDecimals = _decimals;\n        _initialized = true;\n        \n        // Transfer ownership to vault\n        _transferOwnership(_vault);\n        \n        // Pause token trading during funding period\n        _pause();\n    }\n    \n    /**\n     * @dev Pre-transfer checks\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n        \n        // Check pause status (allow minting and burning during pause)\n        if (from != address(0) && to != address(0)) {\n            require(!paused(), \"VaultToken: token transfer while paused\");\n        }\n        \n        // Call vault hook on token transfer\n        if (from != address(0) && to != address(0)) {\n            // Only call if vault is a valid contract\n            if (vault.code.length > 0) {\n                IVault(vault).onTokenTransfer(from, to, amount);\n            }\n        }\n    }\n    \n    // ============ Query Interface ============\n    \n    /**\n     * @dev Query if initialized\n     */\n    function isInitialized() external view returns (bool) {\n        return _initialized;\n    }\n    \n\n} "
    },
    "contracts/v2/templates/vault/BasicVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../../interfaces/IVault.sol\";\nimport \"../../interfaces/IToken.sol\";\n\n/**\n * @title BasicVault\n * @dev Basic vault template implementation, providing fundamental storage and permission management\n * @notice This contract does not contain specific business logic, business functions are implemented by other modules\n */\ncontract BasicVault is IVault, Ownable, ReentrancyGuard {\n    // ============ State Variables ============\n    \n    address public override manager;\n    bool public override whitelistEnabled;\n    mapping(address => bool) public override isWhitelisted;\n    address public override validator;\n    bytes public override dataHash;\n    bytes public override signature;\n    \n    // Cross-contract addresses\n    address public accumulatedYield;\n    address public override vaultToken;\n    address public funding;\n    \n\n    \n    // Initialization state\n    bool private _initialized;\n    \n    // ============ Modifiers ============\n    \n    modifier onlyManager() {\n        require(msg.sender == manager, \"BasicVault: only manager\");\n        _;\n    }\n    \n    modifier onlyFunding() {\n        require(msg.sender == funding, \"BasicVault: only funding\");\n        _;\n    }\n    \n    modifier onlyVaultToken() {\n        require(msg.sender == vaultToken, \"BasicVault: only vault token\");\n        _;\n    }\n    \n    modifier whenWhitelisted(address user) {\n        if (whitelistEnabled) {\n            require(isWhitelisted[user], \"BasicVault: not whitelisted\");\n        }\n        _;\n    }\n    \n    modifier whenInitialized() {\n        require(_initialized, \"BasicVault: not initialized\");\n        _;\n    }\n    \n    modifier whenNotInitialized() {\n        require(!_initialized, \"BasicVault: already initialized\");\n        _;\n    }\n    \n    // ============ Constructor ============\n    \n    constructor() {\n    }\n    \n    // ============ Initialization Function ============\n    \n\n    /**\n     * @dev Unified initialization interface\n     * @param _initData Encoded initialization data\n     */\n    function initiate(bytes memory _initData) external override whenNotInitialized {\n        // decode init data\n        (address _manager, address _validator, bool _whitelistEnabled, address[] memory _initialWhitelist) = \n            abi.decode(_initData, (address, address, bool, address[]));\n        \n        _initVault(_manager, _validator, _whitelistEnabled, _initialWhitelist);\n    }\n    \n    // ============ IVault Interface Implementation ============\n    \n    /**\n     * @dev Add address to whitelist\n     * @param _addr Address to add\n     */\n    function addToWhitelist(address _addr) external override onlyManager whenInitialized {\n        _addToWhitelist(_addr);\n    }\n    \n    /**\n     * @dev Remove address from whitelist\n     * @param _addr Address to remove\n     */\n    function removeFromWhitelist(address _addr) external override onlyManager whenInitialized {\n        require(isWhitelisted[_addr], \"BasicVault: not whitelisted\");\n        \n        isWhitelisted[_addr] = false;\n        \n        emit WhitelistRemoved(_addr);\n    }\n    \n    /**\n     * @dev Enable whitelist\n     */\n    function enableWhitelist() external override onlyManager whenInitialized {\n        whitelistEnabled = true;\n        emit WhitelistStatusChanged(true);\n    }\n    \n    /**\n     * @dev Disable whitelist\n     */\n    function disableWhitelist() external override onlyManager whenInitialized {\n        whitelistEnabled = false;\n        emit WhitelistStatusChanged(false);\n    }\n    \n    /**\n     * @dev Check if whitelist is enabled\n     * @return Whether whitelist is enabled\n     */\n    function isWhiteList() external view override returns (bool) {\n        return whitelistEnabled;\n    }\n    \n    /**\n     * @dev Verify data (simple implementation, actual applications need more complex verification logic)\n     * @return Verification result\n     */\n    function verify() external pure override returns (bool) {\n        // Simple verification logic, actual implementation needs to be based on specific requirements\n        return true;\n    }\n    \n    /**\n     * @dev Update verification data\n     * @param hash Data hash\n     * @param _signature Signature data\n     */\n    function updateVerifyData(bytes memory hash, bytes memory _signature) external override onlyManager whenInitialized {\n        dataHash = hash;\n        signature = _signature;\n        emit VerifyDataUpdated(hash, _signature);\n    }\n    \n    /**\n     * @dev Pause token\n     */\n    function pauseToken() external override onlyManager whenInitialized {\n        require(vaultToken != address(0), \"BasicVault: token not set\");\n        IToken(vaultToken).pause();\n        emit TokenPaused();\n    }\n    \n    /**\n     * @dev Unpause token\n     */\n    function unpauseToken() external override whenInitialized {\n        require(msg.sender == manager || msg.sender == funding, \"BasicVault: only manager or funding\");\n        require(vaultToken != address(0), \"BasicVault: token not set\");\n        IToken(vaultToken).unpause();\n        emit TokenUnpaused();\n    }\n    \n    /**\n     * @dev Check if token is paused\n     * @return Whether token is paused\n     */\n    function isTokenPaused() external view override returns (bool) {\n        if (vaultToken == address(0)) {\n            return false;\n        }\n        return IToken(vaultToken).paused();\n    }\n    \n    /**\n     * @dev Mint tokens through vault\n     * @param to Recipient address\n     * @param amount Amount to mint\n     */\n    function mintToken(address to, uint256 amount) external override onlyFunding whenInitialized whenWhitelisted(to) {\n        require(vaultToken != address(0), \"BasicVault: token not set\");\n        IToken(vaultToken).mint(to, amount);\n    }\n    \n    /**\n     * @dev Burn tokens through vault\n     * @param from Address to burn from\n     * @param amount Amount to burn\n     */\n    function burnToken(address from, uint256 amount) external override onlyFunding whenInitialized whenWhitelisted(from) {\n        require(vaultToken != address(0), \"BasicVault: token not set\");\n        IToken(vaultToken).burnFrom(from, amount);\n    }\n    \n    /**\n     * @dev Hook called on token transfer\n     * @param from From address\n     * @param to To address\n     * @param amount Transfer amount\n     */\n    function onTokenTransfer(address from, address to, uint256 amount) external override whenInitialized whenWhitelisted(from) whenWhitelisted(to) {\n        require(msg.sender == vaultToken, \"BasicVault: only token can call\");\n        if (accumulatedYield != address(0) && from != address(0) && to != address(0)) {\n            (bool success, ) = accumulatedYield.call(\n                abi.encodeWithSignature(\n                    \"updateUserPoolsOnTransfer(address,address,uint256)\",\n                    from,\n                    to,\n                    amount\n                )\n            );\n            if (!success) {\n                revert(\"BasicVault: onTokenTransfer failed\");\n            }\n        }\n    }\n    \n    // ============ Vault Token Management ============\n\n    function configureModules(address _vaultToken, address _funding, address _yield) external override onlyOwner whenInitialized {\n        _setVaultToken(_vaultToken);\n        _setFundingModule(_funding);\n        _setDividendModule(_yield);\n    }\n    \n    // \n    function _setVaultToken(address _vaultToken) internal {\n        require(vaultToken == address(0), \"BasicVault: token already set\");\n        require(_vaultToken != address(0), \"BasicVault: invalid token address\");\n        vaultToken = _vaultToken;\n    }\n    // \n    function setVaultToken(address _vaultToken) external override onlyOwner whenInitialized {\n        _setVaultToken(_vaultToken);\n    }\n    \n    /**\n     * @dev Set funding module address (can only be set once)\n     * @param _funding Funding module address\n     */\n    function _setFundingModule(address _funding) internal {\n        require(funding == address(0), \"BasicVault: funding already set\");\n        require(_funding != address(0), \"BasicVault: invalid funding address\");\n        funding = _funding;\n    }\n    function setFundingModule(address _funding) external override onlyOwner whenInitialized {\n        _setFundingModule(_funding);\n    }\n    \n    /**\n     * @dev Set dividend module address (can only be set once)\n     * @param _dividendModule Dividend module address\n     */\n    function _setDividendModule(address _dividendModule) internal {\n        require(accumulatedYield == address(0), \"BasicVault: dividend module already set\");\n        require(_dividendModule != address(0), \"BasicVault: invalid dividend module address\");\n        accumulatedYield = _dividendModule;\n    }\n    function setDividendModule(address _dividendModule) external override onlyOwner whenInitialized {\n        _setDividendModule(_dividendModule);\n    }\n    \n    // ============ Query Functions ============\n    \n    /**\n     * @dev Check if funding is successful by querying the funding module\n     * @return Whether funding is successful\n     */\n    function isFundingSuccessful() external view override returns (bool) {\n        require(funding != address(0), \"BasicVault: funding module not set\");\n        \n        // Call the funding module to check if funding is successful\n        (bool success, bytes memory data) = funding.staticcall(\n            abi.encodeWithSignature(\"isFundingSuccessful()\")\n        );\n        \n        if (!success) {\n            revert(\"BasicVault: failed to query funding status\");\n        }\n        \n        return abi.decode(data, (bool));\n    }\n    \n    /**\n     * @dev Get funding module address\n     * @return Funding module address\n     */\n    function getFundingModule() external view returns (address) {\n        return funding;\n    }\n    \n    /**\n     * @dev Get dividend module address\n     * @return Dividend module address\n     */\n    function getDividendModule() external view returns (address) {\n        return accumulatedYield;\n    }\n    \n    // ============ Internal Functions ============\n    \n    /**\n     * @dev Internal add to whitelist function\n     * @param _addr Address to add\n     */\n    function _addToWhitelist(address _addr) internal {\n        require(_addr != address(0), \"BasicVault: invalid address\");\n        require(!isWhitelisted[_addr], \"BasicVault: already whitelisted\");\n        \n        isWhitelisted[_addr] = true;\n        \n        emit WhitelistAdded(_addr);\n    }\n\n    /**\n     * @dev Initialize vault (for Clones pattern)\n     * @param _manager Manager address\n     * @param _validator Validator address\n     * @param _whitelistEnabled Whether to enable whitelist\n     * @param _initialWhitelist Initial whitelist addresses\n     */\n    function _initVault(\n        address _manager,\n        address _validator,\n        bool _whitelistEnabled,\n        address[] memory _initialWhitelist\n    ) internal whenNotInitialized {\n        require(_manager != address(0), \"BasicVault: invalid manager\");\n        require(_validator != address(0), \"BasicVault: invalid validator\");\n        \n        manager = _manager;\n        validator = _validator;\n        whitelistEnabled = _whitelistEnabled;\n        _initialized = true;\n        \n        // Add initial whitelist\n        for (uint256 i = 0; i < _initialWhitelist.length; i++) {\n            _addToWhitelist(_initialWhitelist[i]);\n        }\n        \n        _transferOwnership(_manager);\n    }\n    \n    // ============ Query Interface ============\n    \n    /**\n     * @dev Query if initialized\n     */\n    function isInitialized() external view returns (bool) {\n        return _initialized;\n    }\n} "
    },
    "contracts/v2/templates/yield/AccumulatedYield.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../../interfaces/IAccumulatedYield.sol\";\nimport \"../../interfaces/IVault.sol\";\n\n/**\n * @title AccumulatedYield\n * @dev Accumulated yield template implementation, providing yield distribution based on token holdings\n * @notice Supports accumulated yield and real-time claiming, similar to MasterChef design\n */\ncontract AccumulatedYield is IAccumulatedYield, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    \n    // ============ State Variables ============\n    \n    GlobalPoolInfo public globalPool;\n    mapping(address => UserInfo) public users;\n    \n    address public vault;\n    address public manager;\n    address public dividendTreasury;\n    \n    // Add nonce for replay protection\n    uint256 public dividendNonce;\n    \n    // Precision constant\n    uint256 private constant PRECISION = 1e18;\n    \n    // ============ Modifiers ============\n    \n    modifier onlyManager() {\n        require(msg.sender == manager, \"AccumulatedYield: only manager\");\n        _;\n    }\n\n    modifier onlyDividendTreasury() {\n        require(msg.sender == dividendTreasury, \"AccumulatedYield: only dividend treasury\");\n        _;\n    }\n    \n    modifier onlyActivePool() {\n        require(globalPool.isActive, \"AccumulatedYield: pool not active\");\n        _;\n    }\n    \n    modifier whenInitialized() {\n        require(globalPool.shareToken != address(0), \"AccumulatedYield: not initialized\");\n        _;\n    }\n    \n    // ============ Constructor ============\n    \n    /**\n     * @dev Constructor\n     */\n    constructor() {\n    }\n    \n    // ============ Global Pool Management ============\n    \n    /**\n     * @dev Set manager\n     * @param _manager New manager address\n     */\n    function setManager(address _manager) external override onlyOwner whenInitialized {\n        require(_manager != address(0), \"AccumulatedYield: invalid manager\");\n        address oldManager = manager;\n        manager = _manager;\n        \n        // If needed, transfer ownership to new manager\n        if (owner() == oldManager) {\n            _transferOwnership(_manager);\n        }\n        \n        emit ManagerUpdated(oldManager, _manager);\n    }\n    \n    /**\n     * @dev Set dividend treasury address\n     * @param _dividendTreasury New dividend treasury address\n     */\n    function setDividendTreasury(address _dividendTreasury) external override onlyManager whenInitialized {\n        require(_dividendTreasury != address(0), \"AccumulatedYield: invalid dividend treasury\");\n        address oldTreasury = dividendTreasury;\n        dividendTreasury = _dividendTreasury;\n        \n        emit DividendTreasuryUpdated(oldTreasury, _dividendTreasury);\n    }\n\n    /**\n     * @dev Unified initialization interface\n     * @param _vault Vault address\n     * @param _vaultToken Vault token address\n     * @param _initData Encoded initialization data (contains token and original initData)\n     */\n    function initiate(address _vault, address _vaultToken, bytes memory _initData) external override {\n        require(_vault != address(0), \"AccumulatedYield: invalid vault\");\n        \n        // decode initData\n        (address rewardToken, address rewardManager, address dividendTreasuryAddr) = \n            abi.decode(_initData, (address, address, address));\n        \n        // init global pool \n        _initGlobalPool(_vault, rewardManager, dividendTreasuryAddr, _vaultToken, rewardToken);\n    }\n    \n    /**\n     * @dev Update global pool status\n     * @param isActive Whether to activate\n     */\n    function updateGlobalPoolStatus(\n        bool isActive\n    ) external override onlyManager whenInitialized {\n        if (isActive) {\n            // require funding successful\n            require(IVault(vault).isFundingSuccessful(), \"AccumulatedYield: funding was not successful\");\n        }\n        globalPool.isActive = isActive;\n    }\n    \n    // ============ User Operations ============\n    \n    /**\n     * @dev User claim rewards\n     */\n    function claimReward() external override onlyActivePool whenInitialized nonReentrant {\n        // First update user pool information\n        _updateUserPool(msg.sender);\n        \n        UserInfo storage user = users[msg.sender];\n        uint256 currentBalance = IERC20(globalPool.shareToken).balanceOf(msg.sender);\n        uint256 pending = _calculatePendingRewardAt(msg.sender, currentBalance);\n        \n        require(pending > 0, \"AccumulatedYield: no pending reward\");\n        \n        // Core calculation formula: reward calculation phase\n        // 3: Update claimed amount\n        user.totalClaimed += pending;\n        user.lastClaimTime = block.timestamp;\n        \n        // Transfer rewards\n        IERC20(globalPool.rewardToken).safeTransfer(msg.sender, pending);\n        \n        emit RewardClaimed(msg.sender, pending, pending, block.timestamp);\n    }\n    \n    // ============ Yield Distribution ============\n    \n    /**\n     * @dev Distribute dividend to global pool\n     * @param dividendAmount Distribution amount\n     * @param signature Dividend signature\n     */\n    function distributeDividend(\n        uint256 dividendAmount,\n        bytes memory signature\n    ) external override onlyDividendTreasury onlyActivePool whenInitialized nonReentrant {\n        require(dividendAmount > 0, \"AccumulatedYield: invalid dividend amount\");\n        \n        // Get validator address from Vault\n        address validator = IVault(vault).validator();\n        require(validator != address(0), \"AccumulatedYield: validator not set\");\n        \n        // Verify signature with nonce to prevent replay attacks\n        bytes32 payload = keccak256(abi.encodePacked(vault, dividendAmount, dividendNonce));\n        bytes32 ethSignedMessageHash = ECDSA.toEthSignedMessageHash(payload);\n        \n        address signer = ECDSA.recover(ethSignedMessageHash, signature);\n        require(signer == validator, \"AccumulatedYield: invalid signature\");\n        \n        // Increment nonce to prevent replay\n        dividendNonce++;\n        \n        // Transfer dividend from manager to this contract\n        IERC20(globalPool.rewardToken).safeTransferFrom(msg.sender, address(this), dividendAmount);\n        \n        // Update global pool\n        globalPool.totalDividend += dividendAmount;\n        globalPool.lastDividendTime = block.timestamp;\n        \n        // Update total accumulated shares: shareTotalSupply * dividendAmount\n        uint256 totalSupply = IERC20(globalPool.shareToken).totalSupply();\n        \n        globalPool.totalAccumulatedShares += totalSupply * dividendAmount;\n        \n        emit DividendDistributed(dividendAmount, block.timestamp, validator, signature);\n    }\n    \n    // ============ Token Transfer Related ============\n    \n    /**\n     * @dev Update user pools on token transfer (core functionality)\n     * @param from Transfer from address\n     * @param to Transfer to address\n     * @param amount Transfer amount\n     */\n    function updateUserPoolsOnTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) external override {\n        require(msg.sender == vault, \"AccumulatedYield: only vault can call\");\n        \n        if (from != address(0)) {\n            _updateUserPool(from);\n        }\n        \n        if (to != address(0)) {\n            _updateUserPool(to);\n        }\n        \n        emit ShareTokenTransferred(from, to, amount, block.timestamp);\n    }\n    \n    // ============ Query Interface ============\n    \n    /**\n     * @dev Query global pool information\n     * @return Global pool information structure\n     */\n    function getGlobalPoolInfo() external view override returns (GlobalPoolInfo memory) {\n        return globalPool;\n    }\n    \n    /**\n     * @dev Query user information\n     * @param user User address\n     * @return User information structure\n     */\n    function getUserInfo(address user) external view override returns (UserInfo memory) {\n        return users[user];\n    }\n    \n    /**\n     * @dev Query user's pending rewards\n     * @param user User address\n     * @return Pending reward amount\n     */\n    function pendingReward(address user) external view override returns (uint256) {\n        if (globalPool.shareToken == address(0)) {\n            return 0;\n        }\n        \n        uint256 currentBalance = IERC20(globalPool.shareToken).balanceOf(user);\n        return _calculatePendingRewardAt(user, currentBalance);\n    }\n    \n    /**\n     * @dev Query global pool total dividend amount\n     * @return Total dividend amount\n     */\n    function totalDividend() external view override returns (uint256) {\n        return globalPool.totalDividend;\n    }\n    \n    /**\n     * @dev Query global pool total accumulated shares\n     * @return Total accumulated shares\n     */\n    function totalAccumulatedShares() external view override returns (uint256) {\n        return globalPool.totalAccumulatedShares;\n    }\n    \n    /**\n     * @dev Query current manager\n     * @return Manager address\n     */\n    function getManager() external view override returns (address) {\n        return manager;\n    }\n    \n    /**\n     * @dev Query dividend treasury address\n     * @return Dividend treasury address\n     */\n    function getDividendTreasury() external view override returns (address) {\n        return dividendTreasury;\n    }\n    \n    /**\n     * @dev dividendNonce\n     * @return dividendNonce\n     */\n    function getDividendNonce() external view override onlyDividendTreasury returns (uint256) {\n        return dividendNonce;\n    }\n    \n    /**\n     * @dev Calculate user's accumulated shares at specified balance\n     * @param user User address\n     * @param userBalance Specified user balance\n     * @return Accumulated shares\n     */\n    function calculateAccumulatedShares(address user, uint256 userBalance) external view override returns (uint256) {\n        if (globalPool.shareToken == address(0)) {\n            return 0;\n        }\n        \n        UserInfo memory userInfo = users[user];\n        \n        // Calculate dividend delta\n        uint256 deltaDiv = globalPool.totalDividend - userInfo.lastClaimDividend;\n        \n        // Accumulated shares = user's current accumulated shares + specified balance * dividend delta\n        uint256 accumulatedShares = userInfo.accumulatedShares + userBalance * deltaDiv;\n        \n        return accumulatedShares;\n    }\n    \n\n    \n    // ============ Internal Functions ============\n    /**\n     * @dev Initialize global yield pool\n     * @param _vault Vault contract address\n     * @param _manager Manager address\n     * @param _dividendTreasury Dividend treasury address\n     * @param shareToken Share token address\n     * @param rewardToken Reward token address\n     */\n    function _initGlobalPool(\n        address _vault,\n        address _manager,\n        address _dividendTreasury,\n        address shareToken,\n        address rewardToken\n    ) internal {\n        // Can only initialize once, cannot re-initialize\n        require(globalPool.shareToken == address(0), \"AccumulatedYield: already initialized\");\n        require(_vault != address(0), \"AccumulatedYield: invalid vault\");\n        require(_manager != address(0), \"AccumulatedYield: invalid manager\");\n        require(_dividendTreasury != address(0), \"AccumulatedYield: invalid dividend treasury\");\n        require(shareToken != address(0), \"AccumulatedYield: invalid share token\");\n        require(rewardToken != address(0), \"AccumulatedYield: invalid reward token\");\n        \n        // Set vault, manager and dividendTreasury\n        vault = _vault;\n        manager = _manager;\n        dividendTreasury = _dividendTreasury;\n        \n        // Set owner as manager\n        _transferOwnership(_manager);\n        \n        globalPool = GlobalPoolInfo({\n            totalAccumulatedShares: 0,\n            lastDividendTime: block.timestamp,\n            totalDividend: 0,\n            isActive: false,\n            shareToken: shareToken,\n            rewardToken: rewardToken\n        });\n        \n        emit GlobalPoolInitialized(shareToken, rewardToken, block.timestamp);\n    }\n    \n    /**\n     * @dev Update user pool information\n     * @param user User address\n     */\n    function _updateUserPool(address user) internal {\n        if (globalPool.shareToken == address(0)) {\n            return;\n        }\n        \n        UserInfo storage userInfo = users[user];\n        uint256 currentBalance = IERC20(globalPool.shareToken).balanceOf(user);\n        \n        // Core calculation formula: user operation phase\n        // 1: Calculate dividend delta\n        uint256 deltaDiv = globalPool.totalDividend - userInfo.lastClaimDividend;\n        \n        if (deltaDiv > 0) {\n            // 2: Update user accumulated shares\n            userInfo.accumulatedShares += currentBalance * deltaDiv;\n        }\n        \n        // 3: Update user checkpoint\n        userInfo.lastClaimDividend = globalPool.totalDividend;\n        \n        emit UserPoolUpdated(user, userInfo.accumulatedShares, block.timestamp);\n    }\n    \n\n    \n    /**\n     * @dev Calculate user's pending rewards at specified balance\n     * @param user User address\n     * @param userBalance User balance\n     * @return Pending reward amount\n     */\n    function _calculatePendingRewardAt(address user, uint256 userBalance) internal view returns (uint256) {\n        if (globalPool.shareToken == address(0) || globalPool.totalAccumulatedShares == 0) {\n            return 0;\n        }\n        \n        UserInfo memory userInfo = users[user];\n        \n        // Simulate user pool update, calculate latest accumulated shares\n        uint256 simulatedAccumulatedShares = userInfo.accumulatedShares;\n        uint256 deltaDiv = globalPool.totalDividend - userInfo.lastClaimDividend;\n        \n        if (deltaDiv > 0) {\n            simulatedAccumulatedShares += userBalance * deltaDiv;\n        }\n        \n        if (simulatedAccumulatedShares == 0) {\n            return 0;\n        }\n        \n        // Core calculation formula: reward calculation phase with improved precision\n        // 1: Calculate user's total reward with higher precision\n        uint256 totalReward;\n        if (globalPool.totalAccumulatedShares > 0) {\n            // Use higher precision calculation to avoid precision loss\n            totalReward = (simulatedAccumulatedShares * globalPool.totalDividend * PRECISION) / globalPool.totalAccumulatedShares;\n            totalReward = totalReward / PRECISION; // Convert back to original precision\n        } else {\n            totalReward = 0;\n        }\n        \n        // 2: Calculate pending reward\n        uint256 pending = totalReward > userInfo.totalClaimed ? totalReward - userInfo.totalClaimed : 0;\n        \n        return pending;\n    }\n    \n\n} "
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true
      }
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}